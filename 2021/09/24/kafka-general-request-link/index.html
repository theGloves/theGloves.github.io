<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>kafka通用请求链路 | infinite</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="（这是笔者在美团实习时做的一次源码分享，当时直接将本文当作slide，所以很多地方写得比较简略）本文以Kafka 0.10.0为例，追踪broker端通用请求处理链路。本文侧重一个请求在Kafka的组件中如何流转，不会涉及太多网络层（Java NIO）和请求具体的处理实现。 总体流程TODO 流程图，时序 一个请求完整的请求链路：  客户端请求建立连接 acceptor监听到连接事件，客户端的新连">
<meta property="og:type" content="article">
<meta property="og:title" content="kafka通用请求链路">
<meta property="og:url" content="https://thegloves.github.io/2021/09/24/kafka-general-request-link/index.html">
<meta property="og:site_name" content="infinite">
<meta property="og:description" content="（这是笔者在美团实习时做的一次源码分享，当时直接将本文当作slide，所以很多地方写得比较简略）本文以Kafka 0.10.0为例，追踪broker端通用请求处理链路。本文侧重一个请求在Kafka的组件中如何流转，不会涉及太多网络层（Java NIO）和请求具体的处理实现。 总体流程TODO 流程图，时序 一个请求完整的请求链路：  客户端请求建立连接 acceptor监听到连接事件，客户端的新连">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-24T08:28:04.000Z">
<meta property="article:modified_time" content="2023-05-28T12:54:58.343Z">
<meta property="article:author" content="theGloves">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="kafka">
<meta property="article:tag" content="源码阅读">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="infinite" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">infinite</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://theGloves.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-kafka-general-request-link" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/24/kafka-general-request-link/" class="article-date">
  <time datetime="2021-09-24T08:28:04.000Z" itemprop="datePublished">2021-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      kafka通用请求链路
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>（这是笔者在美团实习时做的一次源码分享，当时直接将本文当作slide，所以很多地方写得比较简略）<br>本文以Kafka 0.10.0为例，追踪broker端通用请求处理链路。本文侧重一个请求在Kafka的组件中如何流转，不会涉及太多网络层（Java NIO）和请求具体的处理实现。</p>
<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>TODO 流程图，时序</p>
<p>一个请求完整的请求链路：</p>
<ol>
<li>客户端请求建立连接</li>
<li>acceptor监听到连接事件，客户端的新连接到来</li>
<li>acceptor将新连接分配给某个processor，连接建立成功，processor等待收到客户端的请求就绪</li>
<li>客户端发送请求，processor监听到请求就绪事件</li>
<li>解析请求，转换成内部的request数据，加入到requestQueue中</li>
<li>handler从request queue中poll到请求</li>
<li>将请求转移给KafkaAPIs组件处理</li>
<li>handler或者延时组件生成对应的response，写到请求所在processor的response queue中</li>
<li>processor每次poll从自己的response queue取出response</li>
<li>processor将response写入对应的Socket Channel</li>
<li>网络线程将response返回给客户端</li>
</ol>
<h2 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h2><p>通过KafkaServer的启动流程，了解到和通用请求处理相关的组件有三个：</p>
<ol>
<li>SocketServer：负责连接的建立、接受request和发送response<ul>
<li>RequestChannel：这个组件比较特殊，它是连接Socket和Apis的逻辑channel，由SocketServer负责管理</li>
</ul>
</li>
<li>KafkaApis：统一的请求处理入口，将请求转交给对应的组件处理。同时Apis也要负责控制请求的频率</li>
<li>KafkaRequestHandlerPool：存放requestHandler的pool</li>
</ol>
<p>TODO 逻辑视图</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>, time: <span class="type">Time</span> = <span class="type">SystemTime</span>, threadNamePrefix: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Start up API for bringing up a single instance of the Kafka server.</span></span><br><span class="line"><span class="comment">   * Instantiates the LogManager, the SocketServer and the request handlers - KafkaRequestHandlers</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startup</span></span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      info(<span class="string">"starting"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(isShuttingDown.get)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Kafka server is still shutting down, cannot re-start!"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(startupComplete.get)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> canStartup = isStartingUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (canStartup) &#123;</span><br><span class="line">        metrics = <span class="keyword">new</span> <span class="type">Metrics</span>(metricConfig, reporters, kafkaMetricsTime, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        brokerState.newState(<span class="type">Starting</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start scheduler */</span></span><br><span class="line">        kafkaScheduler.startup()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* setup zookeeper */</span></span><br><span class="line">        zkUtils = initZk()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start log manager */</span></span><br><span class="line">        logManager = createLogManager(zkUtils.zkClient, brokerState)</span><br><span class="line">        logManager.startup()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* generate brokerId */</span></span><br><span class="line">        config.brokerId =  getBrokerId</span><br><span class="line">        <span class="keyword">this</span>.logIdent = <span class="string">"[Kafka Server "</span> + config.brokerId + <span class="string">"], "</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 初始化好acceptor线程和processor线程，注册好监听事件</span></span><br><span class="line">        socketServer = <span class="keyword">new</span> <span class="type">SocketServer</span>(config, metrics, kafkaMetricsTime)</span><br><span class="line">        socketServer.startup()</span><br><span class="line">        <span class="comment">// 到这里，broker其实已经能够接受连接和请求了，只是请求还没法处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... replica、controller、group coordinator、authorizer等组件的初始化和启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* start processing requests */</span></span><br><span class="line">        apis = <span class="keyword">new</span> <span class="type">KafkaApis</span>(socketServer.requestChannel, replicaManager, groupCoordinator,</span><br><span class="line">          kafkaController, zkUtils, config.brokerId, config, metadataCache, metrics, authorizer)</span><br><span class="line">        <span class="comment">// 初始化好requestHandler线程，完成后broker可以开始正常工作</span></span><br><span class="line">        requestHandlerPool = <span class="keyword">new</span> <span class="type">KafkaRequestHandlerPool</span>(config.brokerId, socketServer.requestChannel, apis, config.numIoThreads)</span><br><span class="line">        brokerState.newState(<span class="type">RunningAsBroker</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">        fatal(<span class="string">"Fatal error during KafkaServer startup. Prepare to shutdown"</span>, e)</span><br><span class="line">        isStartingUp.set(<span class="literal">false</span>)</span><br><span class="line">        shutdown()</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kafka启动时，会先初始化好socket server，然后再去初始化接口KafkaApis和handler线程。下面我们依次深入三个关键组件的初始化和启动</p>
<h3 id="SocketServer"><a href="#SocketServer" class="headerlink" title="SocketServer"></a>SocketServer</h3><p>SocketServer负责网络相关的事件：连接的管理、request和response的收发。SocketServer的核心是network NIO，简单来说，就是用户以异步的方式来等待网络数据准备好，不会因为等待某个请求，使得整个线程阻塞住。从使用上来看，线程每隔一段时间就去网络层那里查看有没有传输完的请求，如果有就处理，没有就随用户操作。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>SocketServer的初始化主要是根据配置，为acceptor线程和processor线程的array预留好空间，同时初始化好RequestChannel</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>, val metrics: <span class="type">Metrics</span>, val time: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> endpoints = config.listeners <span class="comment">// "listeners" broker监听的端口列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> numProcessorThreads = config.numNetworkThreads <span class="comment">// "num.network.threads" 配置里设置的网络线程数N</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> maxQueuedRequests = config.queuedMaxRequests <span class="comment">// "queued.max.requests" 请求队列的长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> totalProcessorThreads = numProcessorThreads * endpoints.size <span class="comment">// 总共的网络线程数，一个endpoint会有N个网络线程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIp = config.maxConnectionsPerIp <span class="comment">// "max.connections.per.ip" 每个ip最大的连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIpOverrides = config.maxConnectionsPerIpOverrides <span class="comment">// "max.connections.per.ip.overrides" ？</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logIdent = <span class="string">"[Socket Server on Broker "</span> + config.brokerId + <span class="string">"], "</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> requestChannel = <span class="keyword">new</span> <span class="type">RequestChannel</span>(totalProcessorThreads, maxQueuedRequests) <span class="comment">// 连接SocketServer和KafkaAPi的逻辑channel，存放两种关键队列：requestQueue、responseQueue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> processors = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Processor</span>](totalProcessorThreads) <span class="comment">// 所有的网络线程组成一个Array，每N个网络线程属于同一个endpoint</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[network] <span class="keyword">val</span> acceptors = mutable.<span class="type">Map</span>[<span class="type">EndPoint</span>, <span class="type">Acceptor</span>]() <span class="comment">// acceptor线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> connectionQuotas: <span class="type">ConnectionQuotas</span> = _ <span class="comment">// 》</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> allMetricNames = (<span class="number">0</span> until totalProcessorThreads).map &#123; i =&gt;</span><br><span class="line">    <span class="keyword">val</span> tags = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]()</span><br><span class="line">    tags.put(<span class="string">"networkProcessor"</span>, i.toString)</span><br><span class="line">    metrics.metricName(<span class="string">"io-wait-ratio"</span>, <span class="string">"socket-server-metrics"</span>, tags)</span><br><span class="line">  &#125; <span class="comment">// 每个processor的io-ratio统计指标</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// register the processor threads for notification of responses</span></span><br><span class="line">  requestChannel.addResponseListener(id =&gt; processors(id).wakeup())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SocketServer</span>负责<span class="type">RequstChannel</span>的初始化 - 主要是两种队列的初始化：requestQueue和responseQueue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestChannel</span>(<span class="params">val numProcessors: <span class="type">Int</span>, val queueSize: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 主要是两种队列的初始化，需要注意的是</span></span><br><span class="line">  <span class="comment">// 所有线程共用一个requestQueue</span></span><br><span class="line">  <span class="comment">// 每个processor线程各自拥有ResponseQueue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> responseListeners: <span class="type">List</span>[(<span class="type">Int</span>) =&gt; <span class="type">Unit</span>] = <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> requestQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Request</span>](queueSize)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> responseQueues = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">BlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]](numProcessors)</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until numProcessors)</span><br><span class="line">    responseQueues(i) = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>用户可以给Kafka配置多个监听地址endpoint，SocketServer启动时会为每个endpoint启动一个acceptor线程，然后每一个acceptor线程配N个processor线程。当acceptor线程启动成功后，SocketServer的启动也随之完成。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>, val metrics: <span class="type">Metrics</span>, val time: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startup</span></span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.synchronized &#123;</span><br><span class="line">      connectionQuotas = <span class="keyword">new</span> <span class="type">ConnectionQuotas</span>(maxConnectionsPerIp, maxConnectionsPerIpOverrides) <span class="comment">// 连接数计数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> sendBufferSize = config.socketSendBufferBytes <span class="comment">// "socket.send.buffer.bytes" 发送缓存区大小</span></span><br><span class="line">      <span class="keyword">val</span> recvBufferSize = config.socketReceiveBufferBytes <span class="comment">// "socket.receive.buffer.bytes" 接受缓存区大小</span></span><br><span class="line">      <span class="keyword">val</span> brokerId = config.brokerId <span class="comment">// "broker.id"</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> processorBeginIndex = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 一个endpoint对应一个acceptor，一个acceptor对应N个processor</span></span><br><span class="line">      endpoints.values.foreach &#123; endpoint =&gt;</span><br><span class="line">        <span class="keyword">val</span> protocol = endpoint.protocolType</span><br><span class="line">        <span class="keyword">val</span> processorEndIndex = processorBeginIndex + numProcessorThreads</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- processorBeginIndex until processorEndIndex) &#123;</span><br><span class="line">          <span class="comment">// 初始化Processor线程，主要是初始化Selector</span></span><br><span class="line">          processors(i) = newProcessor(i, connectionQuotas, protocol)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里启动的processor线程</span></span><br><span class="line">        <span class="comment">// 初始化acceptor线程，同时启动绑定的processor线程</span></span><br><span class="line">        <span class="keyword">val</span> acceptor = <span class="keyword">new</span> <span class="type">Acceptor</span>(endpoint, sendBufferSize, recvBufferSize, brokerId,</span><br><span class="line">          processors.slice(processorBeginIndex, processorEndIndex), connectionQuotas)</span><br><span class="line">        acceptors.put(endpoint, acceptor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里为什么不用daemon方式启动线程？</span></span><br><span class="line">        <span class="type">Utils</span>.newThread(<span class="string">"kafka-socket-acceptor-%s-%d"</span>.format(protocol.toString, endpoint.port), acceptor, <span class="literal">false</span>).start()</span><br><span class="line">        acceptor.awaitStartup() <span class="comment">// 在这里等待acceptor启动成功后才恢复执行（acceptor注册OP_ACCEPT事件成功）</span></span><br><span class="line">        processorBeginIndex = processorEndIndex</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newGauge(<span class="string">"NetworkProcessorAvgIdlePercent"</span>,</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Gauge</span>[<span class="type">Double</span>] &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">value</span> </span>= allMetricNames.map( metricName =&gt;</span><br><span class="line">          metrics.metrics().get(metricName).value()).sum / totalProcessorThreads</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Started "</span> + acceptors.size + <span class="string">" acceptor threads"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KafkaApis"><a href="#KafkaApis" class="headerlink" title="KafkaApis"></a>KafkaApis</h3><p>不展开看了，主要是配额器quotaManager的初始化。KafkaApis的主要功能就是将request dispatch到相应的组件上</p>
<h3 id="KafkaRequestHandlerPool"><a href="#KafkaRequestHandlerPool" class="headerlink" title="KafkaRequestHandlerPool"></a>KafkaRequestHandlerPool</h3><p>在初始化KafkaRequestHandlerPool时，SocketServer已经启动好了，说明所有的acceptor和processor已经就绪，broker已经能够接受请求了，所以KafkaRequestHandlerPool的初始化主要完成KafkaRequestHandler线程的启动，启动成功后就可以开始处理请求。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaRequestHandlerPool</span>(<span class="params">val brokerId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              val requestChannel: <span class="type">RequestChannel</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              val apis: <span class="type">KafkaApis</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              numThreads: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* a meter to track the average free capacity of the request handlers */</span></span><br><span class="line">  <span class="comment">// handler的idle percent指标是聚合后的结果</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> aggregateIdleMeter = newMeter(<span class="string">"RequestHandlerAvgIdlePercent"</span>, <span class="string">"percent"</span>, <span class="type">TimeUnit</span>.<span class="type">NANOSECONDS</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logIdent = <span class="string">"[Kafka Request Handler on Broker "</span> + brokerId + <span class="string">"], "</span></span><br><span class="line">  <span class="comment">// TODO 弄清楚threads和runnables的区别</span></span><br><span class="line">  <span class="keyword">val</span> threads = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Thread</span>](numThreads) <span class="comment">// 后台启动的handler线程</span></span><br><span class="line">  <span class="keyword">val</span> runnables = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">KafkaRequestHandler</span>](numThreads) <span class="comment">// 存放handler线程</span></span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until numThreads) &#123;</span><br><span class="line">    runnables(i) = <span class="keyword">new</span> <span class="type">KafkaRequestHandler</span>(i, brokerId, aggregateIdleMeter, numThreads, requestChannel, apis)</span><br><span class="line">    <span class="comment">// 以Daemon方式启动线程</span></span><br><span class="line">    threads(i) = <span class="type">Utils</span>.daemonThread(<span class="string">"kafka-request-handler-"</span> + i, runnables(i))</span><br><span class="line">    threads(i).start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>() &#123;</span><br><span class="line">    info(<span class="string">"shutting down"</span>)</span><br><span class="line">    <span class="keyword">for</span>(handler &lt;- runnables)</span><br><span class="line">      handler.shutdown</span><br><span class="line">    <span class="keyword">for</span>(thread &lt;- threads)</span><br><span class="line">      thread.join</span><br><span class="line">    info(<span class="string">"shut down completely"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>通过前面的总体流程，我们可以看到一个请求会在不同的线程中处理和转发，在这一部分，我们会关注每个线程具体的操作。总的来说，Kafka的网络线程模型采用的 Reactor 多线程模型：一个1+N+M模型：1个acceptor，N个processor，M个handler</p>
<ul>
<li>acceptor：监听端口，接受新连接的到来，将新连接以轮询的方式派发给processor</li>
<li>processor：接受request，发送response</li>
<li>handler：通过requestQueue，处理processor发来的request，生成response加入到response queue中</li>
</ul>
<p>网络模型除了reactor模型外，还有Proactor模型，本文不再展开，如果有兴趣可以参阅高性能网络框架：Reactor 和 Proactor TOOD link</p>
<h3 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h3><p>acceptor的主要工作是监听端口，将新来的连接以轮询的方式派发给自己拥有的processor线程。因为acceptor处于连接入口，所以acceptor同时肩负着控制连接数的重任。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 注册OP_ACCEPT事件，当有新的客户端连接到来时，事件触发</span></span><br><span class="line">  <span class="comment">// 类似的事件还有OP_CONNECT，但是OP_CONNECT只能给client端使用，语义：SocketChannel.connect()请求连接成功后就绪</span></span><br><span class="line">  serverChannel.register(nioSelector, <span class="type">SelectionKey</span>.<span class="type">OP_ACCEPT</span>)</span><br><span class="line">  startupComplete() <span class="comment">// 计数减1，当计数为0时唤醒所有的await，在这里执行成功之后SocketServer.startup()被唤醒继续执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentProcessor = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> ready = nioSelector.select(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> (ready &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果有新的连接</span></span><br><span class="line">          <span class="keyword">val</span> keys = nioSelector.selectedKeys()</span><br><span class="line">          <span class="keyword">val</span> iter = keys.iterator()</span><br><span class="line">          <span class="keyword">while</span> (iter.hasNext &amp;&amp; isRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">val</span> key = iter.next</span><br><span class="line">              iter.remove()</span><br><span class="line">              <span class="keyword">if</span> (key.isAcceptable)</span><br><span class="line">                 <span class="comment">// round-robin，processor只是简单地将该连接的channel加到一个list中，等到下一次poll在更新</span></span><br><span class="line">                accept(key, processors(currentProcessor))</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Unrecognized key state for acceptor thread."</span>)</span><br><span class="line"></span><br><span class="line">              <span class="comment">// round robin to the next processor thread</span></span><br><span class="line">              currentProcessor = (currentProcessor + <span class="number">1</span>) % processors.length</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error while accepting connection"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// We catch all the throwables to prevent the acceptor thread from exiting on exceptions due</span></span><br><span class="line">        <span class="comment">// to a select operation on a specific channel or a bad request. We don't want the</span></span><br><span class="line">        <span class="comment">// the broker to stop responding to requests from other clients in these scenarios.</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error occurred"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    debug(<span class="string">"Closing server socket and selector."</span>)</span><br><span class="line">    swallowError(serverChannel.close())</span><br><span class="line">    swallowError(nioSelector.close())</span><br><span class="line">    shutdownComplete()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新连接到来时acceptor具体的操作：为新来的连接生成好socketChannel，然后将socketChannel转移给processor。但是processor收到新连接，并不会马上处理，而是将其暂时缓存，到下一轮poll统一处理</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acceptor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(key: <span class="type">SelectionKey</span>, processor: <span class="type">Processor</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> serverSocketChannel = key.channel().asInstanceOf[<span class="type">ServerSocketChannel</span>]</span><br><span class="line">    <span class="keyword">val</span> socketChannel = serverSocketChannel.accept() <span class="comment">// accept什么？</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里如果同一个address的连接数超过限制则会抛出TooManyConnectionsException异常拒绝处理</span></span><br><span class="line">      connectionQuotas.inc(socketChannel.socket().getInetAddress)</span><br><span class="line">      socketChannel.configureBlocking(<span class="literal">false</span>)</span><br><span class="line">      socketChannel.socket().setTcpNoDelay(<span class="literal">true</span>)      <span class="comment">// 开启TCP_NODELAY，禁用Nagle算法，允许小包发送</span></span><br><span class="line">      socketChannel.socket().setKeepAlive(<span class="literal">true</span>)</span><br><span class="line">      socketChannel.socket().setSendBufferSize(sendBufferSize)</span><br><span class="line"></span><br><span class="line">      debug(<span class="string">"Accepted connection from %s on %s and assigned it to processor %d, sendBufferSize [actual|requested]: [%d|%d] recvBufferSize [actual|requested]: [%d|%d]"</span></span><br><span class="line">            .format(socketChannel.socket.getRemoteSocketAddress, socketChannel.socket.getLocalSocketAddress, processor.id,</span><br><span class="line">                  socketChannel.socket.getSendBufferSize, sendBufferSize,</span><br><span class="line">                  socketChannel.socket.getReceiveBufferSize, recvBufferSize))</span><br><span class="line"></span><br><span class="line">      processor.accept(socketChannel) <span class="comment">// 将channel转移给processor处理，processor只是简单的加到一个队列中，等待下一轮poll才会真正处理心连接</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">TooManyConnectionsException</span> =&gt;</span><br><span class="line">        info(<span class="string">"Rejected connection from %s, address already has the configured maximum of %d connections."</span>.format(e.ip, e.count))</span><br><span class="line">        close(socketChannel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(socketChannel: <span class="type">SocketChannel</span>) &#123;</span><br><span class="line">    newConnections.add(socketChannel)</span><br><span class="line">    wakeup() <span class="comment">// 如果selector因为IO block，那么唤醒它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processor线程"><a href="#processor线程" class="headerlink" title="processor线程"></a>processor线程</h3><p>processor负责接收客户端的请求，同时将请求结果回复给客户端。processor一次循环会依次处理：</p>
<ol>
<li>注册上一轮poll期间acceptor分配来的新连接</li>
<li>处理新的response任务</li>
<li>执行selector.poll，等待IO事件</li>
<li>处理新的就绪请求，将其加入到RequstQueue</li>
<li>处理发送成功的response，将发送完的response从inflightResponse队列中删除</li>
<li>如果有连接关闭，将与其相关的response从inflightResponse队列中删除</li>
</ol>
<p>TODO 这里的顺序可以变动吗</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">   startupComplete() <span class="comment">// 已经启动，计数器减一，不过暂时没有地方等待processor的启动成功</span></span><br><span class="line">   <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// setup any new connections that have been queued up</span></span><br><span class="line">       <span class="comment">// 1.首先注册上一轮poll期间到达的新连接</span></span><br><span class="line">       configureNewConnections()</span><br><span class="line">       <span class="comment">// register any new responses for writing</span></span><br><span class="line">       processNewResponses() <span class="comment">// 2. 处理这个processor的新的response任务</span></span><br><span class="line">       poll() <span class="comment">// 3.selector.poll(300)，如果有就绪消息事件，或者超时事件发生，否则会一直block</span></span><br><span class="line">       processCompletedReceives() <span class="comment">// 4.处理完整接收好的请求，加入到requestQueue，这一步会因为竞争被阻塞</span></span><br><span class="line">       processCompletedSends() <span class="comment">// 5.更新inflightResponses队列，将发送完的response从队列中删除</span></span><br><span class="line">       processDisconnected() <span class="comment">// 6.有连接关闭，清理inflightResponses队列中相关的response</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">       <span class="comment">// We catch all the throwables here to prevent the processor thread from exiting. We do this because</span></span><br><span class="line">       <span class="comment">// letting a processor exit might cause a bigger impact on the broker. Usually the exceptions thrown would</span></span><br><span class="line">       <span class="comment">// be either associated with a specific socket channel or a bad request. We just ignore the bad socket channel</span></span><br><span class="line">       <span class="comment">// or request. This behavior might need to be reviewed if we see an exception that need the entire broker to stop.</span></span><br><span class="line">       <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">       <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">         error(<span class="string">"Processor got uncaught exception."</span>, e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   debug(<span class="string">"Closing selector - processor "</span> + id)</span><br><span class="line">   swallowError(closeAll())</span><br><span class="line">   shutdownComplete()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册新连接"><a href="#注册新连接" class="headerlink" title="注册新连接"></a>注册新连接</h3><p>主要要向selector注册新连接的ON_READ事件，后续收到数据才能被唤醒</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">configureNewConnections</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!newConnections.isEmpty) &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = newConnections.poll()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      debug(<span class="string">s"Processor <span class="subst">$id</span> listening to new connection from <span class="subst">$&#123;channel.socket.getRemoteSocketAddress&#125;</span>"</span>)</span><br><span class="line">      <span class="keyword">val</span> localHost = channel.socket().getLocalAddress.getHostAddress</span><br><span class="line">      <span class="keyword">val</span> localPort = channel.socket().getLocalPort</span><br><span class="line">      <span class="keyword">val</span> remoteHost = channel.socket().getInetAddress.getHostAddress</span><br><span class="line">      <span class="keyword">val</span> remotePort = channel.socket().getPort</span><br><span class="line">      <span class="comment">// 生成唯一的connectionId</span></span><br><span class="line">      <span class="keyword">val</span> connectionId = <span class="type">ConnectionId</span>(localHost, localPort, remoteHost, remotePort).toString</span><br><span class="line">      <span class="comment">// 向selector注册channel的OP_READ事件</span></span><br><span class="line">      selector.register(connectionId, channel)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// We explicitly catch all non fatal exceptions and close the socket to avoid a socket leak. The other</span></span><br><span class="line">      <span class="comment">// throwables will be caught in processor and logged as uncaught exceptions.</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        <span class="comment">// need to close the channel here to avoid a socket leak.</span></span><br><span class="line">        close(channel)</span><br><span class="line">        error(<span class="string">s"Processor <span class="subst">$id</span> closed connection from <span class="subst">$&#123;channel.getRemoteAddress&#125;</span>"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理新的response"><a href="#处理新的response" class="headerlink" title="处理新的response"></a>处理新的response</h3><p>将新的response发送给selector后，将其加入到inflightResponse中，inflightResponse表示正在发送的response</p>
<p>TODO 插入一点NIO的基本知识</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processNewResponses</span></span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> curr = requestChannel.receiveResponse(id)</span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      curr.responseAction <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">NoOpAction</span> =&gt;</span><br><span class="line">          <span class="comment">// There is no response to send to the client, we need to read more pipelined requests</span></span><br><span class="line">          <span class="comment">// that are sitting in the server's socket buffer</span></span><br><span class="line">          curr.request.updateRequestMetrics</span><br><span class="line">          trace(<span class="string">"Socket server received empty response to send, registering for read: "</span> + curr)</span><br><span class="line">          <span class="comment">// 请求不需要回复，已经处理完，unmute channel</span></span><br><span class="line">          selector.unmute(curr.request.connectionId)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">SendAction</span> =&gt;</span><br><span class="line">          <span class="comment">// 将response发送给selector</span></span><br><span class="line">          sendResponse(curr)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">CloseConnectionAction</span> =&gt;</span><br><span class="line">          curr.request.updateRequestMetrics</span><br><span class="line">          trace(<span class="string">"Closing socket connection actively according to the response code."</span>)</span><br><span class="line">          close(selector, curr.request.connectionId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      curr = requestChannel.receiveResponse(id) <span class="comment">// 循环迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* `protected` for test usage */</span></span><br><span class="line"><span class="keyword">protected</span>[network] <span class="function"><span class="keyword">def</span> <span class="title">sendResponse</span></span>(response: <span class="type">RequestChannel</span>.<span class="type">Response</span>) &#123;</span><br><span class="line">  trace(<span class="string">s"Socket server received response to send, registering for write and sending data: <span class="subst">$response</span>"</span>)</span><br><span class="line">  <span class="keyword">val</span> channel = selector.channel(response.responseSend.destination)</span><br><span class="line">  <span class="comment">// `channel` can be null if the selector closed the connection because it was idle for too long</span></span><br><span class="line">  <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 连接关闭了</span></span><br><span class="line">    warn(<span class="string">s"Attempting to send response via channel for which there is no open connection, connection id <span class="subst">$id</span>"</span>)</span><br><span class="line">    response.request.updateRequestMetrics()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将response发送给selector，然后将其加入到inflightResponses队列</span></span><br><span class="line">    selector.send(response.responseSend)</span><br><span class="line">    inflightResponses += (response.request.connectionId -&gt; response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>主要是调用selector.poll函数，这个函数以non-blocking的方式完成网络IO操作，如果没有就绪的请求，最多等待300ms返回</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">poll</span></span>() &#123;</span><br><span class="line">   <span class="keyword">try</span> selector.poll(<span class="number">300</span>) <span class="comment">//在这里沉睡</span></span><br><span class="line">   <span class="keyword">catch</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> e @ (_: <span class="type">IllegalStateException</span> | _: <span class="type">IOException</span>) =&gt;</span><br><span class="line">       error(<span class="string">s"Closing processor <span class="subst">$id</span> due to illegal state or IO exception"</span>)</span><br><span class="line">       swallow(closeAll())</span><br><span class="line">       shutdownComplete()</span><br><span class="line">       <span class="keyword">throw</span> e</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理新的就绪请求"><a href="#处理新的就绪请求" class="headerlink" title="处理新的就绪请求"></a>处理新的就绪请求</h3><p>processor将就绪请求封装成内部的Request数据，然后将其加入到RequestQueue队列， 这一步会发生锁竞争导致堵塞。</p>
<p>另外，需要注意的是，为了保证同一个连接的请求保持一来一回的顺序，请求之间保持有序，Kafka使用了mute机制</p>
<p>TODO 疑问 为什么要共用一把锁</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedReceives</span></span>() &#123;</span><br><span class="line">  selector.completedReceives.asScala.foreach &#123; receive =&gt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> channel = selector.channel(receive.source)</span><br><span class="line">      <span class="keyword">val</span> session = <span class="type">RequestChannel</span>.<span class="type">Session</span>(<span class="keyword">new</span> <span class="type">KafkaPrincipal</span>(<span class="type">KafkaPrincipal</span>.<span class="type">USER_TYPE</span>, channel.principal.getName),</span><br><span class="line">        channel.socketAddress)</span><br><span class="line">      <span class="keyword">val</span> req = <span class="type">RequestChannel</span>.<span class="type">Request</span>(processor = id, connectionId = receive.source, session = session, buffer = receive.payload, startTimeMs = time.milliseconds, securityProtocol = protocol)</span><br><span class="line">      <span class="comment">// 这里会阻塞，requestQueue是ArrayBlockingQueue</span></span><br><span class="line">      requestChannel.sendRequest(req)</span><br><span class="line">      <span class="comment">// 为了保证同一个连接上请求的有序性：后来的请求的回复不会先于早来的到达，会mute这个channel，直到请求的回复被对方接受</span></span><br><span class="line">      selector.mute(receive.source)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e @ (_: <span class="type">InvalidRequestException</span> | _: <span class="type">SchemaException</span>) =&gt;</span><br><span class="line">        <span class="comment">// note that even though we got an exception, we can assume that receive.source is valid. Issues with constructing a valid receive object were handled earlier</span></span><br><span class="line">        error(<span class="string">s"Closing socket for <span class="subst">$&#123;receive.source&#125;</span> because of error"</span>, e)</span><br><span class="line">        close(selector, receive.source)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理发送成功的response"><a href="#处理发送成功的response" class="headerlink" title="处理发送成功的response"></a>处理发送成功的response</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedSends</span></span>() &#123;</span><br><span class="line">  selector.completedSends.asScala.foreach &#123; send =&gt;</span><br><span class="line">    <span class="comment">// 将已经发送成功的response从inflightResponse中删除</span></span><br><span class="line">    <span class="keyword">val</span> resp = inflightResponses.remove(send.destination).getOrElse &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"Send for <span class="subst">$&#123;send.destination&#125;</span> completed, but not in `inflightResponses`"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.request.updateRequestMetrics()</span><br><span class="line">    <span class="comment">// 恢复channel的监听</span></span><br><span class="line">    selector.unmute(send.destination)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接关闭收尾"><a href="#连接关闭收尾" class="headerlink" title="连接关闭收尾"></a>连接关闭收尾</h3><p>处理两件事：</p>
<ul>
<li>更新inflightResponse，将相关的response删除</li>
<li>更新ConnectionQuota</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processDisconnected</span></span>() &#123;</span><br><span class="line">  selector.disconnected.asScala.foreach &#123; connectionId =&gt;</span><br><span class="line">    <span class="keyword">val</span> remoteHost = <span class="type">ConnectionId</span>.fromString(connectionId).getOrElse &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"connectionId has unexpected format: <span class="subst">$connectionId</span>"</span>)</span><br><span class="line">    &#125;.remoteHost</span><br><span class="line">    <span class="comment">// 删除所有和connectionId相关的response，同时更新metrics</span></span><br><span class="line">    inflightResponses.remove(connectionId).foreach(_.request.updateRequestMetrics())</span><br><span class="line">    <span class="comment">// the channel has been closed by the selector but the quotas still need to be updated</span></span><br><span class="line">    <span class="comment">// 更新Quota，</span></span><br><span class="line">    connectionQuotas.dec(<span class="type">InetAddress</span>.getByName(remoteHost))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KafkaRequestHandler线程"><a href="#KafkaRequestHandler线程" class="headerlink" title="KafkaRequestHandler线程"></a>KafkaRequestHandler线程</h2><p>handler从requestQueue中拉取请求，然后通过KafkaApis将请求dispatch到相应的组件上继续处理，handler主要负责两件事：</p>
<ul>
<li>请求的执行，一般会把请求从KafkaApis转移到其他组件继续执行</li>
<li>生成response，一般是把生成response的操作封装成一个函数，将其传入到其他组件。当其他组件处理完请求时，调用回调函数生成response消息，并将其追加到相应processor的response queue中。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> req : <span class="type">RequestChannel</span>.<span class="type">Request</span> = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">while</span> (req == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We use a single meter for aggregate idle percentage for the thread pool.</span></span><br><span class="line">        <span class="comment">// Since meter is calculated as total_recorded_value / time_window and</span></span><br><span class="line">        <span class="comment">// time_window is independent of the number of threads, each recorded idle</span></span><br><span class="line">        <span class="comment">// time should be discounted by # threads.</span></span><br><span class="line">        <span class="keyword">val</span> startSelectTime = <span class="type">SystemTime</span>.nanoseconds</span><br><span class="line">        <span class="comment">// receiveRequest有两个实现，还有一个无参实现，两者的区别在于调用ArrayBlockingQueue不同的接口</span></span><br><span class="line">        <span class="comment">// 带timeout的调用queue.poll(timeout) ，如果没有数据等待timeout后返回空</span></span><br><span class="line">        <span class="comment">// 无参的调用queue.take() 如果没有数据，则会挂起等待，直到有数据</span></span><br><span class="line">        req = requestChannel.receiveRequest(<span class="number">300</span>)</span><br><span class="line">        <span class="keyword">val</span> idleTime = <span class="type">SystemTime</span>.nanoseconds - startSelectTime</span><br><span class="line">        aggregateIdleMeter.mark(idleTime / totalHandlerThreads)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(req eq <span class="type">RequestChannel</span>.<span class="type">AllDone</span>) &#123;</span><br><span class="line">        <span class="comment">// 当上层关闭KafkaRequestHandlerPool，会依次调用每个handler的shutdown</span></span><br><span class="line">        <span class="comment">// 每个handler往RequestQueue里发送AllDone请求，通知run loop退出</span></span><br><span class="line">        debug(<span class="string">"Kafka request handler %d on broker %d received shut down command"</span>.format(</span><br><span class="line">          id, brokerId))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      req.requestDequeueTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line">      trace(<span class="string">"Kafka request handler %d on broker %d handling request %s"</span>.format(id, brokerId, req))</span><br><span class="line">      apis.handle(req) <span class="comment">// dispatch，请求处理转移到KafkaApis，之后在转到请求对应的组件去</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Exception when handling request"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KafkaApis.handle根据不同的请求，调用不同的函数处理</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    trace(<span class="string">"Handling request:%s from connection %s;securityProtocol:%s,principal:%s"</span>.</span><br><span class="line">      format(request.requestDesc(<span class="literal">true</span>), request.connectionId, request.securityProtocol, request.session.principal))</span><br><span class="line">    <span class="type">ApiKeys</span>.forId(request.requestId) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">// 可以看到，所有的请求都是流经同一个request queue，没有优先级的区别</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">PRODUCE</span> =&gt; handleProducerRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">FETCH</span> =&gt; handleFetchRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LIST_OFFSETS</span> =&gt; handleOffsetRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">METADATA</span> =&gt; handleTopicMetadataRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LEADER_AND_ISR</span> =&gt; handleLeaderAndIsrRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">STOP_REPLICA</span> =&gt; handleStopReplicaRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">UPDATE_METADATA_KEY</span> =&gt; handleUpdateMetadataRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">CONTROLLED_SHUTDOWN_KEY</span> =&gt; handleControlledShutdownRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">OFFSET_COMMIT</span> =&gt; handleOffsetCommitRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">OFFSET_FETCH</span> =&gt; handleOffsetFetchRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">GROUP_COORDINATOR</span> =&gt; handleGroupCoordinatorRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">JOIN_GROUP</span> =&gt; handleJoinGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">HEARTBEAT</span> =&gt; handleHeartbeatRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LEAVE_GROUP</span> =&gt; handleLeaveGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">SYNC_GROUP</span> =&gt; handleSyncGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">DESCRIBE_GROUPS</span> =&gt; handleDescribeGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LIST_GROUPS</span> =&gt; handleListGroupsRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">SASL_HANDSHAKE</span> =&gt; handleSaslHandshakeRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">API_VERSIONS</span> =&gt; handleApiVersionsRequest(request)</span><br><span class="line">      <span class="keyword">case</span> requestId =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KafkaException</span>(<span class="string">"Unknown api code "</span> + requestId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">      <span class="keyword">if</span> (request.requestObj != <span class="literal">null</span>) &#123;</span><br><span class="line">        request.requestObj.handleError(e, requestChannel, request)</span><br><span class="line">        error(<span class="string">"Error when handling request %s"</span>.format(request.requestObj), e)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = request.body.getErrorResponse(request.header.apiVersion, e)</span><br><span class="line">        <span class="keyword">val</span> respHeader = <span class="keyword">new</span> <span class="type">ResponseHeader</span>(request.header.correlationId)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If request doesn't have a default error response, we just close the connection.</span></span><br><span class="line"><span class="comment">           For example, when produce request has acks set to 0 */</span></span><br><span class="line">        <span class="keyword">if</span> (response == <span class="literal">null</span>)</span><br><span class="line">          requestChannel.closeConnection(request.processor, request)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">Response</span>(request, <span class="keyword">new</span> <span class="type">ResponseSend</span>(request.connectionId, respHeader, response)))</span><br><span class="line"></span><br><span class="line">        error(<span class="string">"Error when handling request %s"</span>.format(request.body), e)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span></span><br><span class="line">    request.apiLocalCompleteTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面我们以「follower fetch」为例，梳理一下KafkaApi侧完成一次请求需要的流程：</p>
<p>验证fetch请求合法性</p>
<ul>
<li>定义回调函数sendResponseCallback，重新定义了fetch请求的response结构和send结构</li>
<li>转到replica组件继续执行fetch请求，同时传入sendResponseCallback等结束调用生成response</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle a fetch request</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleFetchRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> fetchRequest = request.requestObj.asInstanceOf[<span class="type">FetchRequest</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 验证请求合法性，</span></span><br><span class="line">  <span class="keyword">val</span> (authorizedRequestInfo, unauthorizedRequestInfo) = fetchRequest.requestInfo.partition &#123;</span><br><span class="line">    <span class="keyword">case</span> (topicAndPartition, _) =&gt; authorize(request.session, <span class="type">Read</span>, <span class="keyword">new</span> <span class="type">Resource</span>(<span class="type">Topic</span>, topicAndPartition.topic))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> unauthorizedPartitionData = unauthorizedRequestInfo.mapValues &#123; _ =&gt;</span><br><span class="line">    <span class="type">FetchResponsePartitionData</span>(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>.code, <span class="number">-1</span>, <span class="type">MessageSet</span>.<span class="type">Empty</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the callback for sending a fetch response</span></span><br><span class="line">  <span class="comment">// 2. 定义回调函数来生成fetch response</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sendResponseCallback</span></span>(responsePartitionData: <span class="type">Map</span>[<span class="type">TopicAndPartition</span>, <span class="type">FetchResponsePartitionData</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> convertedPartitionData =</span><br><span class="line">      <span class="comment">// Need to down-convert message when consumer only takes magic value 0.</span></span><br><span class="line">      <span class="keyword">if</span> (fetchRequest.versionId &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        responsePartitionData.map &#123; <span class="keyword">case</span> (tp, data) =&gt;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We only do down-conversion when:</span></span><br><span class="line">          <span class="comment">// 1. The message format version configured for the topic is using magic value &gt; 0, and</span></span><br><span class="line">          <span class="comment">// 2. The message set contains message whose magic &gt; 0</span></span><br><span class="line">          <span class="comment">// This is to reduce the message format conversion as much as possible. The conversion will only occur</span></span><br><span class="line">          <span class="comment">// when new message format is used for the topic and we see an old request.</span></span><br><span class="line">          <span class="comment">// Please note that if the message format is changed from a higher version back to lower version this</span></span><br><span class="line">          <span class="comment">// test might break because some messages in new message format can be delivered to consumers before 0.10.0.0</span></span><br><span class="line">          <span class="comment">// without format down conversion.</span></span><br><span class="line">          <span class="keyword">val</span> convertedData = <span class="keyword">if</span> (replicaManager.getMessageFormatVersion(tp).exists(_ &gt; <span class="type">Message</span>.<span class="type">MagicValue_V0</span>) &amp;&amp;</span><br><span class="line">            !data.messages.isMagicValueInAllWrapperMessages(<span class="type">Message</span>.<span class="type">MagicValue_V0</span>)) &#123;</span><br><span class="line">            trace(<span class="string">s"Down converting message to V0 for fetch request from <span class="subst">$&#123;fetchRequest.clientId&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">FetchResponsePartitionData</span>(data.error, data.hw, data.messages.asInstanceOf[<span class="type">FileMessageSet</span>].toMessageFormat(<span class="type">Message</span>.<span class="type">MagicValue_V0</span>))</span><br><span class="line">          &#125; <span class="keyword">else</span> data</span><br><span class="line"></span><br><span class="line">          tp -&gt; convertedData</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> responsePartitionData</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mergedPartitionData = convertedPartitionData ++ unauthorizedPartitionData</span><br><span class="line"></span><br><span class="line">    mergedPartitionData.foreach &#123; <span class="keyword">case</span> (topicAndPartition, data) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (data.error != <span class="type">Errors</span>.<span class="type">NONE</span>.code)</span><br><span class="line">        debug(<span class="string">s"Fetch request with correlation id <span class="subst">$&#123;fetchRequest.correlationId&#125;</span> from client <span class="subst">$&#123;fetchRequest.clientId&#125;</span> "</span> +</span><br><span class="line">          <span class="string">s"on partition <span class="subst">$topicAndPartition</span> failed due to <span class="subst">$&#123;Errors.forCode(data.error).exceptionName&#125;</span>"</span>)</span><br><span class="line">      <span class="comment">// record the bytes out metrics only when the response is being sent</span></span><br><span class="line">      <span class="type">BrokerTopicStats</span>.getBrokerTopicStats(topicAndPartition.topic).bytesOutRate.mark(data.messages.sizeInBytes)</span><br><span class="line">      <span class="type">BrokerTopicStats</span>.getBrokerAllTopicsStats().bytesOutRate.mark(data.messages.sizeInBytes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成response数据的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetchResponseCallback</span></span>(delayTimeMs: <span class="type">Int</span>) &#123;</span><br><span class="line">      trace(<span class="string">s"Sending fetch response to client <span class="subst">$&#123;fetchRequest.clientId&#125;</span> of "</span> +</span><br><span class="line">        <span class="string">s"<span class="subst">$&#123;convertedPartitionData.values.map(_.messages.sizeInBytes).sum&#125;</span> bytes"</span>)</span><br><span class="line">      <span class="comment">// 自己重新实现了Response</span></span><br><span class="line">      <span class="keyword">val</span> response = <span class="type">FetchResponse</span>(fetchRequest.correlationId, mergedPartitionData, fetchRequest.versionId, delayTimeMs)</span><br><span class="line">      <span class="comment">// 没有用ByteBuffer的Send操作，重写了一套send方法，大概是多路写提高效率？</span></span><br><span class="line">      requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="keyword">new</span> <span class="type">FetchResponseSend</span>(request.connectionId, response)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When this callback is triggered, the remote API call has completed</span></span><br><span class="line">    request.apiRemoteCompleteTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not throttle replication traffic</span></span><br><span class="line">    <span class="keyword">if</span> (fetchRequest.isFromFollower) &#123;</span><br><span class="line">      fetchResponseCallback(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      quotaManagers(<span class="type">ApiKeys</span>.<span class="type">FETCH</span>.id).recordAndMaybeThrottle(fetchRequest.clientId,</span><br><span class="line">                                                             <span class="type">FetchResponse</span>.responseSize(mergedPartitionData.groupBy(_._1.topic),</span><br><span class="line">                                                                                        fetchRequest.versionId),</span><br><span class="line">                                                             fetchResponseCallback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (authorizedRequestInfo.isEmpty)</span><br><span class="line">    sendResponseCallback(<span class="type">Map</span>.empty)</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3. call the replica manager to fetch messages from the local replica</span></span><br><span class="line">    replicaManager.fetchMessages(</span><br><span class="line">      fetchRequest.maxWait.toLong,</span><br><span class="line">      fetchRequest.replicaId,</span><br><span class="line">      fetchRequest.minBytes,</span><br><span class="line">      authorizedRequestInfo,</span><br><span class="line">      sendResponseCallback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h2><p>整个请求链路中，存在两个对外的数据接口：Request和Response，分别对应着请求链路的入口和出口。</p>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>生成request时候需要传入processor和connectId信息，因为response是根据request生成的，生成好后需要根据request的processor信息将response放到相同processor的responseQueue中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// request和processor绑定，因为相应的response也要回到相同的processor上</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">processor: <span class="type">Int</span>, connectionId: <span class="type">String</span>, session: <span class="type">Session</span>, private var buffer: <span class="type">ByteBuffer</span>, startTimeMs: <span class="type">Long</span>, securityProtocol: <span class="type">SecurityProtocol</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// These need to be volatile because the readers are in the network thread and the writers are in the request</span></span><br><span class="line">    <span class="comment">// handler threads or the purgatory threads</span></span><br><span class="line">    <span class="comment">// 记录一个请求不同阶段的耗，在调用updateRequestMetrics函数前，记录的是毫秒级别的时间戳</span></span><br><span class="line">    <span class="comment">// updateRequestMetrics会在processor执行processNewResponses函数时统一调用，在计算出正确的结果</span></span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> requestDequeueTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> apiLocalCompleteTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> responseCompleteTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> responseDequeueTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> apiRemoteCompleteTimeMs = <span class="number">-1</span>L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> requestId = buffer.getShort()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this will be removed once we migrated to client-side format</span></span><br><span class="line">    <span class="comment">// for server-side request / response format</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> this map only includes the server-side request/response handlers. Newer</span></span><br><span class="line">    <span class="comment">// request types should only use the client-side versions which are parsed with</span></span><br><span class="line">    <span class="comment">// o.a.k.common.requests.AbstractRequest.getRequest()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyToNameAndDeserializerMap: <span class="type">Map</span>[<span class="type">Short</span>, (<span class="type">ByteBuffer</span>) =&gt; <span class="type">RequestOrResponse</span>]=</span><br><span class="line">      <span class="type">Map</span>(<span class="type">ApiKeys</span>.<span class="type">FETCH</span>.id -&gt; <span class="type">FetchRequest</span>.readFrom,</span><br><span class="line">        <span class="type">ApiKeys</span>.<span class="type">CONTROLLED_SHUTDOWN_KEY</span>.id -&gt; <span class="type">ControlledShutdownRequest</span>.readFrom</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this will be removed once we migrated to client-side format</span></span><br><span class="line">    <span class="keyword">val</span> requestObj =</span><br><span class="line">      keyToNameAndDeserializerMap.get(requestId).map(readFrom =&gt; readFrom(buffer)).orNull</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we failed to find a server-side mapping, then try using the</span></span><br><span class="line">    <span class="comment">// client-side request / response format</span></span><br><span class="line">    <span class="keyword">val</span> header: <span class="type">RequestHeader</span> =</span><br><span class="line">      <span class="keyword">if</span> (requestObj == <span class="literal">null</span>) &#123;</span><br><span class="line">        buffer.rewind</span><br><span class="line">        <span class="keyword">try</span> <span class="type">RequestHeader</span>.parse(buffer)</span><br><span class="line">        <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> ex: <span class="type">Throwable</span> =&gt;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidRequestException</span>(<span class="string">s"Error parsing request header. Our best guess of the apiKey is: <span class="subst">$requestId</span>"</span>, ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> body: <span class="type">AbstractRequest</span> =</span><br><span class="line">      <span class="keyword">if</span> (requestObj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// For unsupported version of ApiVersionsRequest, create a dummy request to enable an error response to be returned later</span></span><br><span class="line">          <span class="keyword">if</span> (header.apiKey == <span class="type">ApiKeys</span>.<span class="type">API_VERSIONS</span>.id &amp;&amp; !<span class="type">Protocol</span>.apiVersionSupported(header.apiKey, header.apiVersion))</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ApiVersionsRequest</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="type">AbstractRequest</span>.getRequest(header.apiKey, header.apiVersion, buffer)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> ex: <span class="type">Throwable</span> =&gt;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidRequestException</span>(<span class="string">s"Error getting request for apiKey: <span class="subst">$&#123;header.apiKey&#125;</span> and apiVersion: <span class="subst">$&#123;header.apiVersion&#125;</span>"</span>, ex)</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    buffer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> requestLogger = <span class="type">Logger</span>.getLogger(<span class="string">"kafka.request.logger"</span>)</span><br><span class="line"></span><br><span class="line">    trace(<span class="string">"Processor %d received request : %s"</span>.format(processor, requestDesc(<span class="literal">true</span>)))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>(<span class="params">processor: <span class="type">Int</span>, request: <span class="type">Request</span>, responseSend: <span class="type">Send</span>, responseAction: <span class="type">ResponseAction</span></span>) </span>&#123;</span><br><span class="line">  request.responseCompleteTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(processor: <span class="type">Int</span>, request: <span class="type">Request</span>, responseSend: <span class="type">Send</span>) =</span><br><span class="line">    <span class="keyword">this</span>(processor, request, responseSend, <span class="keyword">if</span> (responseSend == <span class="literal">null</span>) <span class="type">NoOpAction</span> <span class="keyword">else</span> <span class="type">SendAction</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(request: <span class="type">Request</span>, send: <span class="type">Send</span>) =</span><br><span class="line">    <span class="keyword">this</span>(request.processor, request, send)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ResponseAction</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">SendAction</span> <span class="keyword">extends</span> <span class="title">ResponseAction</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">NoOpAction</span> <span class="keyword">extends</span> <span class="title">ResponseAction</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">CloseConnectionAction</span> <span class="keyword">extends</span> <span class="title">ResponseAction</span></span></span><br></pre></td></tr></table></figure>

<p>与常见的Response有些不同，Kafka的Response不关注返回数据本身，而是关注数据如何写入socket channel，所以response主要保存的是一个函数接口send，这个接口描述了response数据以何种方式写入到channel中。processor收到这个response时，也只是将其传入NIO的队列，等待NIO网络线程想要执行发送操作时，才会调用writeTo函数，按照上层定义的方式写入数据。Send接口的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This interface models the in-progress sending of data to a destination identified by an integer id.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public interface <span class="type">Send</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The numeric id for the destination of this send</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="type">String</span> destination();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is this send complete?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public boolean completed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write some as-yet unwritten bytes from this send to the provided channel. It may take multiple calls for the send</span></span><br><span class="line"><span class="comment">     * to be completely written</span></span><br><span class="line"><span class="comment">     * @param channel The Channel to write to</span></span><br><span class="line"><span class="comment">     * @return The number of bytes written</span></span><br><span class="line"><span class="comment">     * @throws IOException If the write fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public long writeTo(<span class="type">GatheringByteChannel</span> channel) <span class="keyword">throws</span> <span class="type">IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Size of the send</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public long size();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后续版本变动"><a href="#后续版本变动" class="headerlink" title="后续版本变动"></a>后续版本变动</h2><p><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-291%3A+Separating+controller+connections+and+requests+from+the+data+plane" target="_blank" rel="noopener">KIP-291</a><br><a href="https://issues.apache.org/jira/browse/KAFKA-4453" target="_blank" rel="noopener">Kafka-4453</a></p>
<p>0.10.0版本下，所有的控制流请求和数据流请求都在同一个request queue，如果拥堵，会导致控制流请求没法得到及时更新。所以后续的社区更新将两个流拆分成两个独立的链路，从endpoint、acceptor、processor、handler、requestQueue、APIs等，都互不干扰。当然，两者占有的资源并不是等同的，毕竟控制流请求相对会更少，一般会配备1个acceptor线程、1个processor线程和20个位置requestQueue</p>
<h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>文本通过源码阅读的方式，简略梳理了broker侧的请求处理链路，但仍有一些问题遗留：</p>
<ul>
<li>为什么acceptor、processor以普通用户线程运行，而handler则是以daemon线程运行</li>
<li>网络层selector仍是一个黑盒子，Kafka在Java network NIO的基础上进行了一些封装。</li>
<li>如果界定一个请求的边界，怎么定义一个请求的收到</li>
<li>为什么会有组件自己实现Send接口，而不是简单地使用ByteNetworkSend</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></li>
<li><a href="https://bbs.huaweicloud.com/blogs/266248?utm_source=zhihu&utm_medium=bbs-ex&utm_campaign=other&utm_content=content" target="_blank" rel="noopener">高性能网络框架：Reactor 和 Proactor</a></li>
<li><a href="http://matt33.com/2018/06/27/kafka-server-process-model" target="_blank" rel="noopener">Kafka 源码解析之 Server 1+N+M 网络处理模型</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://thegloves.github.io/2021/09/24/kafka-general-request-link/" data-id="cli7gx0wn000avowdajrp6ole" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/09/24/index-md/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hi, welcome to my blog
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/others/">others</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 10px;">源码阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/28/basic-raft-protocol/">basic raft protocol</a>
          </li>
        
          <li>
            <a href="/2022/07/20/tla/">tla+</a>
          </li>
        
          <li>
            <a href="/2021/11/02/cloud-FS/">基于k8s+rancher+NFS搭建云平台</a>
          </li>
        
          <li>
            <a href="/2021/09/24/index-md/">Hi, welcome to my blog</a>
          </li>
        
          <li>
            <a href="/2021/09/24/kafka-general-request-link/">kafka通用请求链路</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 theGloves<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
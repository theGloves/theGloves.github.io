<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>infinite</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="infinite">
<meta property="og:url" content="https://thegloves.github.io/index.html">
<meta property="og:site_name" content="infinite">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="theGloves">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="infinite" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">infinite</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://theGloves.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-basic-raft-protocol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/28/basic-raft-protocol/" class="article-date">
  <time datetime="2023-05-28T12:57:53.000Z" itemprop="datePublished">2023-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/28/basic-raft-protocol/">basic raft protocol</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="01-Basic-Raft协议"><a href="#01-Basic-Raft协议" class="headerlink" title="01 Basic Raft协议"></a>01 Basic Raft协议</h1><blockquote>
<p>本文目标：分享笔者自己对Basic Raft的流程和设计目的。为了降低复杂度，本次不涉及任何<strong>性能优化</strong>和<strong>成员变更</strong>，只关注正确性（也称safety）</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>多副本机制是提高系统容灾能力的手段之一。使用多副本机制引入一个新的问题——如何让不同副本的数据保持一样。客观上，副本之间有快有慢，数据会存在不一样的时刻（苛求数据同时写入所有副本本身就是不可能的）。通过共识协议解决副本之间的数据一致性问题：我们可以通过共识算法对用户屏蔽副本之间的差异，最理想的情况就是用户使用起来和单副本没区别，感知不到副本的存在。</p>
<p>不少项目如etcd、TiDB等均采用Raft作为他们的共识协议。本文基于Ongaro的<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf" target="_blank" rel="noopener">博士论文</a>中的第三章，首先介绍basic Raft（后文均简称Raft）的流程；然后结合笔者自己的理解，讨论协议的设计思路；最后简单讨论协议的正确性。</p>
<h2 id="Basic-Raft"><a href="#Basic-Raft" class="headerlink" title="Basic Raft"></a>Basic Raft</h2><p>Raft使用复制状态机（replicated state machine）来对副本进行抽象。关于复制状态机的定义我们这里就不展开介绍，如果感兴趣推荐阅读Leslie Lamport的<a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf" target="_blank" rel="noopener">Time, Clocks and the Ordering of Events in a Distributed System</a></p>
<p>这里我们以KV数据库为例，每个副本都是一个独立的KV数据库，这个数据库用状态机来表示。每个状态机有一个输入序列（后文也会称replicated log），序列中的每一个动作是一个对数据库的变更，比如set(x) = 10。所有状态机从一个统一的初态开始，读取输入序列中的动作依次执行。</p>
<p>假设不同状态机的输入序列中是完全一样，可以预见的是：<strong>每个状态机执行到相同位置的动作时，不同节点的数据库是一摸一样的</strong>。</p>
<p>那么如何保证输入序列中是完全一样呢？由Raft来保证为所有复制状态机提供一个完全一致的replicated log，从而间接实现所有副本的数据是一致的。</p>
<p><img src="statemachine.png" alt></p>
<p>那么我们怎么评价一个共识是正确的呢？与算法的正确性类似，算法存在一个不变式，在运行过程中要一直保持该不变式不被打破，可以认为该算法是正确的。这样的不变式在分布式协议中通常被叫做<strong>Safety属性</strong>。这里我们可以给出State Machine Safety来定义复制状态机的一致性，在Raft运行过程中，要保证时刻满足State Machine Safety，否则都会让副本出现不一致的状态。</p>
<blockquote>
<p>State Machine Safety</p>
<p>If a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. </p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>一个Raft共识组内有n个副本（n一般为3或5）。Raft协议首先通过选举算法选出一个leader，由<strong>leader负责日志同步</strong>——leader接受client的写请求封装为日志，然后将该日志发送到所有副本；当leader感知到超过一半的节点都成功写入该日志后，向client返回ack确认。这个ack向client保证该日志被保存在大多数个副本上的replicated log中相同的位置上。每个节点会异步将日志提交到状态机。</p>
<p>leader节点的存在可以简化复制流程：leader全权决定在每个日志的位置。如果出现follower的日志和leader不一样的情形时，follower会丢弃自己的日志，重新从leader同步；整个数据流也会很简单——leader单向流动到其他非leader节点。</p>
<p>可以预见的是，如果leader出现异常，整个复制流程都会停滞，系统会进入不可用状态。选举算法不仅要保证选出一个新的leader来恢复写入外，还需要保证“无损”，即保证State Machine Safety不被打破。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="副本状态"><a href="#副本状态" class="headerlink" title="副本状态"></a>副本状态</h4><p>Raft协议将副本分为3个状态：leader、follower和candidate，副本在任意时刻只会处于其中一个状态。状态跃迁图如下所示。</p>
<p><img src="nodestate.png" alt></p>
<ul>
<li>follower：节点启动/进入一个新term后的状态。follower不会向外发送消息，只会被动接受leader的日志同步或者candidate的投票请求</li>
<li>candidate：节点开启选举的状态。在该状态，candidate会向所有节点广播投票请求</li>
<li>leader：节点当选leader的状态。leader会定期向所有节点广播心跳消息，和处理client的读写请求</li>
</ul>
<h4 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h4><p>Raft协议将时间划分为无限多个term，每个term的时间不固定，可长可短，但是每个term内至多有一个leader节点（也可以没有leader）。每个节点各自维护term，发往其他节点的消息都会附带自己当前的term。接受者会拒绝小于自己term的消息，如果收到一个包含更大term的消息，会将自己的term更新为更大的值，同时将副本状态设置为follower。</p>
<blockquote>
<p>可以将term看作节点之间的逻辑时钟。</p>
</blockquote>
<p><img src="term.png" alt></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>Raft将日志定义为一个三元组&lt;term, index, command&gt;，每个节点都维护自己的 replicated logs，有下面几个约束：</p>
<ol>
<li>日志连续无空洞 =&gt; index值连续</li>
<li>任意两个日志可比: a &lt; b =&gt; a.term &lt; b.term || a.index &lt; b.index<ol>
<li>a &lt; b，理解为a在b前面/更早追加到队列中或者a比b旧。</li>
</ol>
</li>
</ol>
<p><img src="log.png" alt></p>
<h3 id="日志复制协议"><a href="#日志复制协议" class="headerlink" title="日志复制协议"></a>日志复制协议</h3><p>本节我们介绍Raft协议日志复制的详细流程，不妨先假设我们存在一个完美的leader选举算法，确保我们任何在任意<strong>一个term内至多只存在一个leader</strong>，且<strong>任意一个leader都不会打破State Machine Safety</strong>。</p>
<p>在Raft中，leader节点始终只会<strong>追加数据</strong>，不会对已有的数据有任何修改。而follower节点无条件接受leader的数据，当出现相同index的日志存在冲突时，也以leader数据为主。整个复制流程如下：</p>
<ol>
<li>leader节点收到客户端的请求/command后，将其追加到自己的replicated log中，这时候可以确定该command的index</li>
<li>然后并行向所有节点同步这条日志</li>
<li>当leader节点收到过半节点（包括leader）的ack后，就可以向客户端返回ack确认。</li>
</ol>
<p><img src="write.png" alt></p>
<p>当client收到写请求的ack，意味着这条日制被leader判定为<strong>committed</strong>——这个日志可以<strong>安全地提交到状态机</strong>上，即满足State Machine Safety属性。那么leader如何判断一个日志committed呢？一共有两个规则，任意一个满足即可：</p>
<ol>
<li>如果该日志是leader<strong>当前term</strong>内发起同步的，那么leader收到该日志过半节点的ack（这里留一个小疑问，为什么要强调当前term？我们后面的章节再回答这个问题）</li>
<li><strong>（传递性）该日志后面的任意一个日志被判定为committed</strong>。</li>
</ol>
<p>每个节点都会记录最后一条committed日志的index，记为commitIndex。leader根据上面的判定条件更新commitIndex，而follower从leader同步commitIndex。只有在commitIndex之前的消息才可以被状态机执行。每个副本会异步执行commitIndex之前的日志，每个节点会记录最后一条被执行完的日志的index，记为lastApplied。任何时刻都有lastApplied &lt;= commitIndex成立。</p>
<h3 id="响应读请求"><a href="#响应读请求" class="headerlink" title="响应读请求"></a>响应读请求</h3><p>在Raft中，由Leader处理client的读请求（可以做follower read优化）：当client发出一个读请求时，leader会从状态机中完成读请求，然后将结果返回给client。我们仍以一个KV数据库为例，写请求可以表示为set(key) = val的操作，读请求表示为read(key)。写请求会被leader通过复制协议追加到所有副本的replicated log中，而读请求则会从leader的KV数据库中读取对应key的值。</p>
<p>但是当一个写请求（例如set(x) = 10）收到leader的ack，并不意味着这时候发出一个读请求（例如 read(x)）就能马上得到10。因为Raft是将请求写入日志和日志被状态机执行分开，日志被状态机执行并不在写请求的处理路径上。</p>
<p>但是当用户在t1时刻写入一个值，很希望在t1之后就能够读到这个值，不会再读到t1之前的值。线性一致性可以满足这个需求（关于一致性的讨论推荐阅读<a href="https://zhuanlan.zhihu.com/p/560247600" target="_blank" rel="noopener">Replication（上）常见复制模型&amp;分布式系统挑战</a>）。</p>
<p>这里给一个Raft实现线性一致性的方案：leader在收到读请求时，如果发现lastApplied &lt; commitIndex，说明状态机还有已经commit的日志没有执行，那么会先执行这些日志，然后再处理读请求。</p>
<p>容易得到：在<strong>同一个leader内</strong>，线性一致性读这个约束很容易保证：读写请求都由leader处理。但是如果发生leader切换，为了保证线性一致性，就要求<strong>new leader.lastApplied &gt;= old leader.lastApplied</strong>。</p>
<blockquote>
<p>这里的介绍非常浅显&amp;不严谨，实际上线性一致性读在Raft工程实践有很多优化，受限于篇幅在此不展开讨论，如果感兴趣可以阅读论文6.4和<a href="https://cn.pingcap.com/blog/lease-read。" target="_blank" rel="noopener">https://cn.pingcap.com/blog/lease-read。</a></p>
</blockquote>
<h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><p>本节我们介绍Raft的选举算法。通过上文的日志复制，我们可以发现leader在Raft中扮演非常重要的角色。在介绍日志复制时，我们假设存在一个完美的选举算法选出一个正确的leader——任意一个term内至多只存在一个leader，且任意一个leader都不会打破State Machine Safety。我们通过下面两个反例，来看这两个条件被打破后对safety的挑战：</p>
<ol>
<li>同一个term内如果有多个leader节点同时存在。会发生同一个index被不同的leader写入成功，然后给client返回ack，但是数据被另一个leader<strong>覆盖</strong>，副本之间的replicated log不一致；</li>
</ol>
<p><img src="basecase1.png" alt></p>
<ol start="2">
<li>新leader打破State Machine Safety，意味着<strong>新leader没有历史leader committed的日志</strong>。如下图示例，S1和S2在1的位置已经已经commit&amp;执行日志&lt;1,1&gt;，但是新leader S3没有&lt;1,1&gt;，它重新提交&lt;2,1&gt;，那么S3的副本状态机在第1条日志执行的是&lt;2,1&gt;，而S1、S2在第1条日志执行的是&lt;1,1&gt;，不满足State Machine Safety。</li>
</ol>
<p><img src="badcase2.png" alt></p>
<p>对应的，这里给出两个选举算法的safety属性：<strong>Election Safety</strong>和<strong>Leader Completeness</strong>。Election Safety避免同一个term内多leader的现象，从而保证在一个term内所有committed的日志在所有副本都是一致的；Leader Completeness则保证新leader拥有所有历史leader commit的日志。</p>
<blockquote>
<p>Election Safety: At most one leader can be elected in a given term. </p>
<p>Leader Completeness: If a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms.</p>
</blockquote>
<p>现在我们可以提出各种各样的选举算法，只需要保证：当选举算法结束选出一个leader在开始处理请求前，一定满足这两个safety属性。</p>
<hr>
<p>下面我们介绍Raft的leader选举算法。Raft选举算法最核心的策略：让有足够新日志的节点当选leader。</p>
<p>leader节点会定期给所有节点发送心跳消息，心跳消息附带term信息，向其他节点表明<strong>自己是该term的leader</strong>。如果<strong>任意一个</strong>follower节点持续一段时间内都没有接收到合法的leader心跳信息，那么这个follower就会开始选举流程，尝试竞选新term的leader。一个完整的选举流程如下：</p>
<ol>
<li><p>自增当前的term，记为term’，设置选举倒计时；</p>
</li>
<li><p>将节点状态<strong>变更为candidate</strong>，向所有节点发出requestVote（请求中附带<strong>自己最后一条日志的term和index</strong>），尝试获取该节点的投票（默认自己给自己一票赞成票）；</p>
</li>
<li><p>如果收到<strong>过半的赞成票</strong>，将节点状态变更为leader，该节点当选term’的leader，整个选举流程结束；</p>
</li>
<li><p>否则，直到倒计时结束都没有完成流程或者收到一个不低于term‘的leader心跳/日志复制，该节点都会<strong>退回follower状态</strong>，结束这一轮term’的选举。</p>
</li>
</ol>
<p>只有<strong>follower状态的节点才会响应candidate的请求投票</strong>，如果candidate拥有的日志比自己的新，follower会回复candidate赞成票，否则无视。每个follower<strong>在一个term至多投出一个赞成票</strong>，如果有多个candidate，那么follower只会给第一个满足规则的candidate投票。</p>
<p>在一轮选举中，可能会出现多个candidate或者candidate的日志太过落后，导致没有candidate能够赢得选举的情况，那这一轮term不会存在合法的leader，所有candidate会退回follower，然后等待下一次超时重新触发选举。</p>
<hr>
<p>当一个candidate完成流程3，即收到过半的赞成票后，这时候就可以处理client的<strong>写请求</strong>了。那读请求呢？如果不需要线性一致性时，这时候新leader也可以开始响应读请求；如果需要线性一致性读，那么新leader此时不能处理读请求，因为无法确认自己的lastApplied是否超过old leader的lastApplied。但是新leader能够得到的信息是：<strong>自己一定有所有commit的日志</strong>。</p>
<blockquote>
<p>简单证明 新leader一定有所有commit的日志</p>
<p>不妨假设：</p>
<p>一共有3个节点n1、n2、n3</p>
<p>0～10index的消息都已经被历史leader提交；</p>
<p>n3没有第10th的commit log，但是当选leader 。</p>
<p>10th log commit =&gt; 至少有2个节点同步了该日志，所以只能是n1、n2；</p>
<p>n3当选leader =&gt; 除了n3的赞成票外，n1或者n2至少有一个节点投赞成票，不妨假设是n1</p>
<p>=&gt; n1（最后一条日志index是10）认为n3的日志（最后一条日志是9）比自己新，<strong>矛盾</strong></p>
</blockquote>
<p>那么新leader怎么找到一个安全的commitIndex呢？至少需要保证下面不等式成立。</p>
<blockquote>
<p>(old leader.lastApplied &lt;= old leader.commitIndex) &lt; new leader.lastApplied &lt;= new leader.commitIndex) </p>
</blockquote>
<p>前文论述了新leader有历史所有leader commit的日志，那最安全的是把自己所有的日志都变为提交状态即可。要达到这个目的可以有两个思路：</p>
<ol>
<li><p>new leader将所有<strong>不确定提交的日志重新走复制流程</strong>。这里需要对committed的判断条件中的第一个条件放宽：<del>如果该日志是leader当前term内发起同步的</del>，那么leader收到该日志过半节点的ack即可认为该日志可以commit。</p>
</li>
<li><p>完成一个当前term下新日志的同步，通过提交规则中的<strong>传递性</strong>来确保之前所有的日志可以commit。</p>
</li>
</ol>
<p>我们先描述第2个方法后者，在实践中这个日志一般是新leader主动追加一个特殊的日志<strong>no-op</strong>，日志的内容为空。当这个日志满足commit条件时——过半节点同步到该日志，那么该日志之前的所有日志也一定被同步，此时新leader能推导出，<strong>no-op的index一定大于old leader的commitIndex</strong>。</p>
<p>这里我们通过一个反例来论述第一个方法是不可行的：</p>
<p><img src="images/raft/badcase3.png" alt></p>
<ol>
<li>在a中，S1当选term2的leader，正在同步日志&lt;2,2&gt;</li>
<li>在b中，S1刚完成&lt;2,2&gt;同步到S2后就宕机，此时S5能够获得S3、S4和S5的赞成票，当选term3的leader</li>
<li>在c中，S5成功当选term4的leader，它看到&lt;2,2&gt;但不确定是否commit，所以仍用&lt;2,2&gt;（注意这里不是&lt;4,2&gt;因为leader不能修改历史数据）来重新同步，收到3个ack后判断&lt;2,2&gt;可以commit，之后新写&lt;4,2&gt;</li>
<li>两个不同的时间线<ol>
<li>在d1中，S1刚完成&lt;2,2&gt;的提交但没来得及同步&lt;4,3&gt;就宕机，这时S5恢复，并且成功当选term5的leader（因为S3最后一条日志的term是3，大于S2、S3、S4，能够获得足够的赞成票），开始重新同步&lt;3,2&gt;并且收到足够的ack，已经提交的&lt;2,2&gt;被覆盖，State Machine Safety被打破</li>
<li>在d2中，S1正常完成&lt;2,2&gt;和&lt;4,3&gt;的同步和提交。此时S5不可能当选leader</li>
</ol>
</li>
</ol>
<p>通过上面的反例，我们可以发现：对于<strong>历史term</strong>的日志，通过<strong>判断日志保存的副本数过半</strong>后就认为可提交是不安全的，所以在「日志复制协议」中的提交规则会加入在<strong>当前term</strong>的限制。</p>
<h3 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h3><p>可以容忍不过半个节点故障/慢。Raft通过日志复制流程来解决follower节点故障的场景，通过leader选举来解决leader节点故障的场景。</p>
<blockquote>
<p><a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a> 该网站可以可视化raft的运行，可以指定任意节点宕机、重启等</p>
</blockquote>
<h2 id="正确性-证明"><a href="#正确性-证明" class="headerlink" title="正确性/证明"></a>正确性/证明</h2><p>如上文描述，State Machine Safety是我们的最终目标，State Machine Safety达成后就有线性一致性的基础，后续面临的挑战就是怎么对client屏蔽不同副本执行进度不一样。在前文介绍复制状态机时，我们看到如果不同状态机有相同的replicated log时，那么State Machine Safety是很容易满足的，相同的replicated log可以描述为Log Matching，即在不同节点，相同的位置及之前的日志都是一样的。</p>
<p>显然，Log Matching和日志复制相关，在日志复制流程中我们可以看到，在同一个term内，当Election Safety成立时，即只有一个leader，log Matching显然成立，因为leader只会追加数据。如果不发生leader切换，那就是一个完美的结局。。</p>
<p>一旦发生leader切换，为了保证Log Matching不被打破，我们很自然地要求新leader拥有旧leader commit的日志，即Leader Completeness。</p>
<p>所以在论证Raft正确性时，Election Safety和Leader Completeness是两个需要证明的关键点，上文也对Leader Completeness有一个简单描述，这里就不详细展开了，感兴趣的同学可以阅读论文3.6.3节和论文B.3附录中的lemma2和lemma 8的证明。（反证法，利用复制的majority和leader选举的majority一定有交集制造矛盾点，老套路了）</p>
<blockquote>
<p>Election Safety: At most one leader can be elected in a given term. </p>
<p>Log Matching: If two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index. </p>
<p>Leader Completeness:  If a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms. </p>
<p>State Machine Safety:  If a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. </p>
</blockquote>
<h2 id="后续TODO"><a href="#后续TODO" class="headerlink" title="后续TODO"></a>后续TODO</h2><p>basic raft加了许多限制来让协议简单，但是离实践可用还需要很多优化，如preVote、线性一致性读等。预计在2023年底来尝试总结下实践raft遇到的问题及对应优化思路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://thegloves.github.io/2023/05/28/basic-raft-protocol/" data-id="cli7gx0wo000cvowdgraofh1g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tla" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/20/tla/" class="article-date">
  <time datetime="2022-07-20T02:52:34.000Z" itemprop="datePublished">2022-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/20/tla/">tla+</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>分布式协议很难证明其正确性，常规想法是通过测试尽可能覆盖所有可能。但实现是，再多的测试也很难覆盖住所有的可能，如果在线上暴露问题，会造成严重的后果。形式化验证正是为了解决这样的问题，它使用计算机强大的计算能力，暴力的搜索所有可能的行为，检查是否满足事先设定的属性，任何不符合预期的行为都能被发现，从根本上保证算法的正确性。</p>
<p>一句话说，在理论上通过暴力搜索所有的可能保证协议理论的正确性，之后只需要考虑如何正确的实现协议。在出问题时不需要考虑协议是否有问题，而是代码实现的有问题。</p>
<blockquote>
<p>TLA is a language for high-level modeling of digital systems. High-level means: at the design level; above the code level.</p>
</blockquote>
<blockquote>
<p>can help find and correct design errors: errors hard to find by testing; before writing any code</p>
</blockquote>
<p>$\frac{3 \cdot batch size}{clients}$</p>
<h2 id="TLA简介"><a href="#TLA简介" class="headerlink" title="TLA简介"></a>TLA简介</h2><p>TLA+(Temporal Logic of Actions) 是Leslie Lamport开发的一门形式化验证语言，用于程序的设计、建模、文档和验证等，特别是并发系统和分布式系统。TLA+的设计初衷是用简单的数学理论和公式精准地对系统进行描述。</p>
<p>使用TLA+对程序进行形式化验证，首先要用TLA+对程序进行描述，这样的描述称为规范(Specification)。有了Specification以后就可以使用TLC模型检查器来运行它，运行的过程会遍历所有可能的行为，检查Specification中设定的属性，发现非预期的行为。</p>
<p>TLA+在学术界和工业界都有着广泛的应用。(TLA+ Examples)[<a href="https://lamport.azurewebsites.net/tla/tla.html]给出了一些使用TLA+验证过的分布式算法和并发算法。很多分布式算法论文在非形式化的论证介绍之外" target="_blank" rel="noopener">https://lamport.azurewebsites.net/tla/tla.html]给出了一些使用TLA+验证过的分布式算法和并发算法。很多分布式算法论文在非形式化的论证介绍之外</a>, 会附带TLA+的Specification来证明自己的算法是经过形式化验证的。</p>
<h2 id="TLA-videos"><a href="#TLA-videos" class="headerlink" title="TLA videos"></a>TLA videos</h2><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><ul>
<li>TLA is a language for high-level modeling of digital systems. High-level means: at the design level; above the code level.</li>
<li>can help find and correct design errors<ul>
<li>errors hard to find by testing</li>
<li>before writing any code</li>
</ul>
</li>
<li>abstraction helps us understand complex systems</li>
<li>we use TLA+ to ensure the systems we build “work right”. Working right means satifying certain properties.</li>
<li>an exeution of a system is represented as a <strong>sequence</strong> of <strong>discret</strong> <strong>steps</strong>.<ul>
<li>strange to describe a concurrent system, as a sequence of steps. </li>
<li>TLA+ descirbes a step as a state change, an execution is represented as a sequence of states. A step is the change from one state to the next.</li>
<li>TLA+ descibes a state as an assignment of values to variables</li>
</ul>
</li>
<li>[define] call a sequence of states a behavior</li>
<li>[define] a state is an assignment of values to variables, so a state machine is described by:<ul>
<li>what the varables are.</li>
<li>possible initial values of variables.</li>
<li>a realation between their values in the current state and their possible values in the next state.</li>
</ul>
</li>
</ul>
<h3 id="state-machine-in-TLA"><a href="#state-machine-in-TLA" class="headerlink" title="state machine in TLA+"></a>state machine in TLA+</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">------ module SimpleProgram -------</span><br><span class="line">EXTENDS Integers</span><br><span class="line">VARIABLES i, pc</span><br><span class="line"></span><br><span class="line">Init &#x3D;&#x3D; (pc &#x3D;&#x3D; &quot;start&quot;) &#x2F;\ (i&#x3D;0)</span><br><span class="line"></span><br><span class="line">Next &#x3D;&#x3D; \&#x2F; &#x2F;\ pc &#x3D; &quot;start&quot;</span><br><span class="line">           &#x2F;\ i&#39; \in 0..10000</span><br><span class="line">           &#x2F;\ pc&#39; &#x3D; &quot;middle&quot;</span><br><span class="line">        \&#x2F; &#x2F;\ pc &#x3D; &quot;middle&quot;</span><br><span class="line">           &#x2F;\ i&#39; &#x3D; i + 1</span><br><span class="line">           &#x2F;\ pc&#39; &#x3D; &quot;done&quot;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<h3 id="resource-and-tools"><a href="#resource-and-tools" class="headerlink" title="resource and tools"></a>resource and tools</h3><ul>
<li><a href="http://lamport.azurewebsites.net/tla/toolbox.html" target="_blank" rel="noopener">Toolbox</a>The TLA Toolbox is an IDE (integrated development environment) for the TLA+ tools</li>
<li>example:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXTENDS Integers</span><br><span class="line">VARIABLES i, pc   </span><br><span class="line"></span><br><span class="line">Init &#x3D;&#x3D; (pc &#x3D; &quot;start&quot;) &#x2F;\ (i &#x3D; 0)</span><br><span class="line"></span><br><span class="line">Pick &#x3D;&#x3D; &#x2F;\ pc &#x3D; &quot;start&quot;  </span><br><span class="line">        &#x2F;\ i&#39; \in 0..1000</span><br><span class="line">        &#x2F;\ pc&#39; &#x3D; &quot;middle&quot;</span><br><span class="line"></span><br><span class="line">Add1 &#x3D;&#x3D; &#x2F;\ pc &#x3D; &quot;middle&quot; </span><br><span class="line">        &#x2F;\ i&#39; &#x3D; i + 1</span><br><span class="line">        &#x2F;\ pc&#39; &#x3D; &quot;done&quot;  </span><br><span class="line">          </span><br><span class="line">Next &#x3D;&#x3D; Pick \&#x2F; Add1</span><br></pre></td></tr></table></figure>

<ul>
<li>TLC report deadlock means execution stopped when it wasn’t supposed to. termination means execution stopped when it was supposed to</li>
<li>TLAPS (TLA proof system) can check proofs of correctness of algorithm</li>
</ul>
<h3 id="transaction-commit"><a href="#transaction-commit" class="headerlink" title="transaction commit"></a>transaction commit</h3><ul>
<li>All resources managers must agree on whether it committed or aborted. </li>
<li>in tla+, every value is a set</li>
<li>[var |-&gt; expr] means lambda function, for example: sqr == [ i \in 1..42 |-&gt; i^2] equal sqr[i] = i^2 for all i form 1 to 42.</li>
<li>terminology:</li>
</ul>
<table>
<thead>
<tr>
<th>Programming</th>
<th>Math</th>
</tr>
</thead>
<tbody><tr>
<td><del>array</del></td>
<td>function</td>
</tr>
<tr>
<td><del>index set</del></td>
<td>domain</td>
</tr>
<tr>
<td>f[e]</td>
<td><del>f(e)</del></td>
</tr>
</tbody></table>
<p>note: f(e) in tla has another use.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">------------------------------ MODULE TCommit ------------------------------</span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* This specification is explained in &quot;Transaction Commit&quot;, Lecture 5 of   *)</span><br><span class="line">(* the TLA+ Video Course.                                                  *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line">CONSTANT RM       \* The set of participating resource managers</span><br><span class="line"></span><br><span class="line">VARIABLE rmState  \* rmState[rm] is the state of resource manager rm.</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">TCTypeOK &#x3D;&#x3D; </span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The type-correctness invariant                                        *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  rmState \in [RM -&gt; &#123;&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;&#125;]</span><br><span class="line">        </span><br><span class="line">TCInit &#x3D;&#x3D;   rmState &#x3D; [r \in RM |-&gt; &quot;working&quot;]</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The initial predicate.                                                *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line"></span><br><span class="line">canCommit &#x3D;&#x3D; \A r \in RM : rmState[r] \in &#123;&quot;prepared&quot;, &quot;committed&quot;&#125;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* True iff all RMs are in the &quot;prepared&quot; or &quot;committed&quot; state.          *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line"></span><br><span class="line">notCommitted &#x3D;&#x3D; \A r \in RM : rmState[r] # &quot;committed&quot; </span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* True iff no resource manager has decided to commit.                   *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* We now define the actions that may be performed by the RMs, and then    *)</span><br><span class="line">(* define the complete next-state action of the specification to be the    *)</span><br><span class="line">(* disjunction of the possible RM actions.                                 *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line">Prepare(r) &#x3D;&#x3D; &#x2F;\ rmState[r] &#x3D; &quot;working&quot;</span><br><span class="line">              &#x2F;\ rmState&#39; &#x3D; [rmState EXCEPT ![r] &#x3D; &quot;prepared&quot;]</span><br><span class="line"></span><br><span class="line">Decide(r)  &#x3D;&#x3D; \&#x2F; &#x2F;\ rmState[r] &#x3D; &quot;prepared&quot;</span><br><span class="line">                 &#x2F;\ canCommit</span><br><span class="line">                 &#x2F;\ rmState&#39; &#x3D; [rmState EXCEPT ![r] &#x3D; &quot;committed&quot;]</span><br><span class="line">              \&#x2F; &#x2F;\ rmState[r] \in &#123;&quot;working&quot;, &quot;prepared&quot;&#125;</span><br><span class="line">                 &#x2F;\ notCommitted</span><br><span class="line">                 &#x2F;\ rmState&#39; &#x3D; [rmState EXCEPT ![r] &#x3D; &quot;aborted&quot;]</span><br><span class="line"></span><br><span class="line">TCNext &#x3D;&#x3D; \E r \in RM : Prepare(r) \&#x2F; Decide(r)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The next-state action.                                                *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">TCConsistent &#x3D;&#x3D;  </span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* A state predicate asserting that two RMs have not arrived at          *)</span><br><span class="line">  (* conflicting decisions.  It is an invariant of the specification.      *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  \A r1, r2 \in RM : ~ &#x2F;\ rmState[r1] &#x3D; &quot;aborted&quot;</span><br><span class="line">                       &#x2F;\ rmState[r2] &#x3D; &quot;committed&quot;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* The following part of the spec is not discussed in Video Lecture 5.  It *)</span><br><span class="line">(* will be explained in Video Lecture 8.                                   *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line">TCSpec &#x3D;&#x3D; TCInit &#x2F;\ [][TCNext]_rmState</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The complete specification of the protocol written as a temporal      *)</span><br><span class="line">  (* formula.                                                              *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line"></span><br><span class="line">THEOREM TCSpec &#x3D;&gt; [](TCTypeOK &#x2F;\ TCConsistent)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* This theorem asserts the truth of the temporal formula whose meaning  *)</span><br><span class="line">  (* is that the state predicate TCTypeOK &#x2F;\ TCInvariant is an invariant   *)</span><br><span class="line">  (* of the specification TCSpec.  Invariance of this conjunction is       *)</span><br><span class="line">  (* equivalent to invariance of both of the formulas TCTypeOK and         *)</span><br><span class="line">  (* TCConsistent.                                                         *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<h3 id="Two-Phase-Commit"><a href="#Two-Phase-Commit" class="headerlink" title="Two Phase Commit"></a>Two Phase Commit</h3><ul>
<li>TLC will check fewer states if the model sets a sysmmetry set to a set of model values</li>
<li>TLC will miss errors if you claim a set is a symmetry set when it’s not</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">------------------------------ MODULE TwoPhase ------------------------------</span><br><span class="line"></span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* This specification is discussed in &quot;Two-Phase Commit&quot;, Lecture 6 of the *)</span><br><span class="line">(* TLA+ Video Course.  It describes the Two-Phase Commit protocol, in      *)</span><br><span class="line">(* which a transaction manager (TM) coordinates the resource managers      *)</span><br><span class="line">(* (RMs) to implement the Transaction Commit specification of module       *)</span><br><span class="line">(* TCommit.  In this specification, RMs spontaneously issue Prepared       *)</span><br><span class="line">(* messages.  We ignore the Prepare messages that the TM can send to the   *)</span><br><span class="line">(* RMs.                                                                    *)</span><br><span class="line">(*                                                                         *)</span><br><span class="line">(* For simplicity, we also eliminate Abort messages sent by an RM when it  *)</span><br><span class="line">(* decides to abort.  Such a message would cause the TM to abort the       *)</span><br><span class="line">(* transaction, an event represented here by the TM spontaneously deciding *)</span><br><span class="line">(* to abort.                                                               *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line">CONSTANT RM  \* The set of resource managers</span><br><span class="line"></span><br><span class="line">VARIABLES</span><br><span class="line">  rmState,       \* rmState[r] is the state of resource manager r.</span><br><span class="line">  tmState,       \* The state of the transaction manager.</span><br><span class="line">  tmPrepared,    \* The set of RMs from which the TM has received &quot;Prepared&quot;</span><br><span class="line">                 \* messages.</span><br><span class="line">  msgs           </span><br><span class="line">    (***********************************************************************)</span><br><span class="line">    (* In the protocol, processes communicate with one another by sending  *)</span><br><span class="line">    (* messages.  For simplicity, we represent message passing with the    *)</span><br><span class="line">    (* variable msgs whose value is the set of all messages that have been *)</span><br><span class="line">    (* sent.  A message is sent by adding it to the set msgs.  An action   *)</span><br><span class="line">    (* that, in an implementation, would be enabled by the receipt of a    *)</span><br><span class="line">    (* certain message is here enabled by the presence of that message in  *)</span><br><span class="line">    (* msgs.  For simplicity, messages are never removed from msgs.  This  *)</span><br><span class="line">    (* allows a single message to be received by multiple receivers.       *)</span><br><span class="line">    (* Receipt of the same message twice is therefore allowed; but in this *)</span><br><span class="line">    (* particular protocol, that&#39;s not a problem.                          *)</span><br><span class="line">    (***********************************************************************)</span><br><span class="line"></span><br><span class="line">Messages &#x3D;&#x3D;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The set of all possible messages.  Messages of type &quot;Prepared&quot; are    *)</span><br><span class="line">  (* sent from the RM indicated by the message&#39;s rm field to the TM.       *)</span><br><span class="line">  (* Messages of type &quot;Commit&quot; and &quot;Abort&quot; are broadcast by the TM, to be  *)</span><br><span class="line">  (* received by all RMs.  The set msgs contains just a single copy of     *)</span><br><span class="line">  (* such a message.                                                       *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  [type : &#123;&quot;Prepared&quot;&#125;, rm : RM]  \cup  [type : &#123;&quot;Commit&quot;, &quot;Abort&quot;&#125;]</span><br><span class="line">   </span><br><span class="line">TPTypeOK &#x3D;&#x3D;  </span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The type-correctness invariant                                        *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ rmState \in [RM -&gt; &#123;&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;&#125;]</span><br><span class="line">  &#x2F;\ tmState \in &#123;&quot;init&quot;, &quot;done&quot;&#125;</span><br><span class="line">  &#x2F;\ tmPrepared \subseteq RM</span><br><span class="line">  &#x2F;\ msgs \subseteq Messages</span><br><span class="line"></span><br><span class="line">TPInit &#x3D;&#x3D;   </span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The initial predicate.                                                *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ rmState &#x3D; [r \in RM |-&gt; &quot;working&quot;]</span><br><span class="line">  &#x2F;\ tmState &#x3D; &quot;init&quot;</span><br><span class="line">  &#x2F;\ tmPrepared   &#x3D; &#123;&#125;</span><br><span class="line">  &#x2F;\ msgs &#x3D; &#123;&#125;</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* We now define the actions that may be performed by the processes, first *)</span><br><span class="line">(* the TM&#39;s actions, then the RMs&#39; actions.                                *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line">TMRcvPrepared(r) &#x3D;&#x3D;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The TM receives a &quot;Prepared&quot; message from resource manager r.  We     *)</span><br><span class="line">  (* could add the additional enabling condition r \notin tmPrepared,      *)</span><br><span class="line">  (* which disables the action if the TM has already received this         *)</span><br><span class="line">  (* message.  But there is no need, because in that case the action has   *)</span><br><span class="line">  (* no effect; it leaves the state unchanged.                             *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ tmState &#x3D; &quot;init&quot;</span><br><span class="line">  &#x2F;\ [type |-&gt; &quot;Prepared&quot;, rm |-&gt; r] \in msgs</span><br><span class="line">  &#x2F;\ tmPrepared&#39; &#x3D; tmPrepared \cup &#123;r&#125;</span><br><span class="line">  &#x2F;\ UNCHANGED &lt;&lt;rmState, tmState, msgs&gt;&gt;</span><br><span class="line"></span><br><span class="line">TMCommit &#x3D;&#x3D;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The TM commits the transaction; enabled iff the TM is in its initial  *)</span><br><span class="line">  (* state and every RM has sent a &quot;Prepared&quot; message.                     *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ tmState &#x3D; &quot;init&quot;</span><br><span class="line">  &#x2F;\ tmPrepared &#x3D; RM</span><br><span class="line">  &#x2F;\ tmState&#39; &#x3D; &quot;done&quot;</span><br><span class="line">  &#x2F;\ msgs&#39; &#x3D; msgs \cup &#123;[type |-&gt; &quot;Commit&quot;]&#125;</span><br><span class="line">  &#x2F;\ UNCHANGED &lt;&lt;rmState, tmPrepared&gt;&gt;</span><br><span class="line"></span><br><span class="line">TMAbort &#x3D;&#x3D;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The TM spontaneously aborts the transaction.                          *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ tmState &#x3D; &quot;init&quot;</span><br><span class="line">  &#x2F;\ tmState&#39; &#x3D; &quot;done&quot;</span><br><span class="line">  &#x2F;\ msgs&#39; &#x3D; msgs \cup &#123;[type |-&gt; &quot;Abort&quot;]&#125;</span><br><span class="line">  &#x2F;\ UNCHANGED &lt;&lt;rmState, tmPrepared&gt;&gt;</span><br><span class="line"></span><br><span class="line">RMPrepare(r) &#x3D;&#x3D; </span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* Resource manager r prepares.                                          *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ rmState[r] &#x3D; &quot;working&quot;</span><br><span class="line">  &#x2F;\ rmState&#39; &#x3D; [rmState EXCEPT ![r] &#x3D; &quot;prepared&quot;]</span><br><span class="line">  &#x2F;\ msgs&#39; &#x3D; msgs \cup &#123;[type |-&gt; &quot;Prepared&quot;, rm |-&gt; r]&#125;</span><br><span class="line">  &#x2F;\ UNCHANGED &lt;&lt;tmState, tmPrepared&gt;&gt;</span><br><span class="line">  </span><br><span class="line">RMChooseToAbort(r) &#x3D;&#x3D;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* Resource manager r spontaneously decides to abort.  As noted above, r *)</span><br><span class="line">  (* does not send any message in our simplified spec.                     *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ rmState[r] &#x3D; &quot;working&quot;</span><br><span class="line">  &#x2F;\ rmState&#39; &#x3D; [rmState EXCEPT ![r] &#x3D; &quot;aborted&quot;]</span><br><span class="line">  &#x2F;\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;</span><br><span class="line"></span><br><span class="line">RMRcvCommitMsg(r) &#x3D;&#x3D;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* Resource manager r is told by the TM to commit.                       *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ [type |-&gt; &quot;Commit&quot;] \in msgs</span><br><span class="line">  &#x2F;\ rmState&#39; &#x3D; [rmState EXCEPT ![r] &#x3D; &quot;committed&quot;]</span><br><span class="line">  &#x2F;\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;</span><br><span class="line"></span><br><span class="line">RMRcvAbortMsg(r) &#x3D;&#x3D;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* Resource manager r is told by the TM to abort.                        *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  &#x2F;\ [type |-&gt; &quot;Abort&quot;] \in msgs</span><br><span class="line">  &#x2F;\ rmState&#39; &#x3D; [rmState EXCEPT ![r] &#x3D; &quot;aborted&quot;]</span><br><span class="line">  &#x2F;\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;</span><br><span class="line"></span><br><span class="line">TPNext &#x3D;&#x3D;</span><br><span class="line">  \&#x2F; TMCommit \&#x2F; TMAbort</span><br><span class="line">  \&#x2F; \E r \in RM : </span><br><span class="line">       TMRcvPrepared(r) \&#x2F; RMPrepare(r) \&#x2F; RMChooseToAbort(r)</span><br><span class="line">         \&#x2F; RMRcvCommitMsg(r) \&#x2F; RMRcvAbortMsg(r)</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* The material below this point is not discussed in Video Lecture 6.  It  *)</span><br><span class="line">(* will be explained in Video Lecture 8.                                   *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line"></span><br><span class="line">TPSpec &#x3D;&#x3D; TPInit &#x2F;\ [][TPNext]_&lt;&lt;rmState, tmState, tmPrepared, msgs&gt;&gt;</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* The complete spec of the Two-Phase Commit protocol.                   *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line"></span><br><span class="line">THEOREM TPSpec &#x3D;&gt; []TPTypeOK</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* This theorem asserts that the type-correctness predicate TPTypeOK is  *)</span><br><span class="line">  (* an invariant of the specification.                                    *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* We now assert that the Two-Phase Commit protocol implements the         *)</span><br><span class="line">(* Transaction Commit protocol of module TCommit.  The following statement *)</span><br><span class="line">(* imports all the definitions from module TCommit into the current        *)</span><br><span class="line">(* module.                                                                 *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line">INSTANCE TCommit </span><br><span class="line"></span><br><span class="line">THEOREM TPSpec &#x3D;&gt; TCSpec</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">  (* This theorem asserts that the specification TPSpec of the Two-Phase   *)</span><br><span class="line">  (* Commit protocol implements the specification TCSpec of the            *)</span><br><span class="line">  (* Transaction Commit protocol.                                          *)</span><br><span class="line">  (*************************************************************************)</span><br><span class="line">(***************************************************************************)</span><br><span class="line">(* The two theorems in this module have been checked with TLC for six      *)</span><br><span class="line">(* RMs, a configuration with 50816 reachable states, in a little over a    *)</span><br><span class="line">(* minute on a 1 GHz PC.                                                   *)</span><br><span class="line">(***************************************************************************)</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">\* Modification History</span><br><span class="line">\* Last modified Fri Dec 10 11:31:27 CST 2021 by thegloves</span><br><span class="line">\* Created Fri Dec 10 11:31:00 CST 2021 by thegloves</span><br></pre></td></tr></table></figure>

<h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><ul>
<li>finding fault-tolerant distributed algorithmns is hard. They’re easy to get wrong, and hard to find errors by tesing</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://thegloves.github.io/2022/07/20/tla/" data-id="cli7gx0wq000hvowd1h4o9kn9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cloud-FS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/02/cloud-FS/" class="article-date">
  <time datetime="2021-11-02T03:58:35.000Z" itemprop="datePublished">2021-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/others/">others</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/02/cloud-FS/">基于k8s+rancher+NFS搭建云平台</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>研究生期间，利用学校的云服务器搭建了一个k8s集群，使用rancher来做管理软件。我们使用rancher来作为我们的测试发布平台，相比于原始的docker，这种模式更简单快捷。但是面临一些问题，比如缺少一个好的日志工具，来收集和统一查看（短暂的搭建过ELF，但是没有使用起来）；</p>
<p>其次缺少一个存储平台，比如集群一共有16台服务器，我要启动若干个服务测试，服务的调度交由k8s调度，每个服务有着自己的配置文件。发现问题了吧，服务可能会出现在16台服务器中的任意一台上，所以需要拷贝16份副本放在素有服务器的相同位置。开始我们搭建了一套NFS，但是随着测试规模越来越大，NFS的写入成为了测试系统的瓶颈点（后文会具体提到原因）。所以后来采抛弃了这个方案，选择在在部署时候，把同一份文件拷贝到所有服务器上，这样的代价就是一次部署测试的时间会很长。</p>
<p>现在也没有更好的解决方案，选择还是回退到NFS，但和原来的稍有不同，等有时间在详细写写</p>
<h2 id="persistent-volume"><a href="#persistent-volume" class="headerlink" title="persistent volume"></a>persistent volume</h2><h3 id="搭建rancher"><a href="#搭建rancher" class="headerlink" title="搭建rancher"></a>搭建rancher</h3><p>前置（安装docker）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#step0 設置DNS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"DNS1=8.8.8.8"</span> &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"DNS2=8.8.4.4"</span> &gt;&gt; /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">sudo systemctl restart network</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 安裝docker</span></span><br><span class="line">sudo yum update -y</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install docker-ce-18.03.1.ce -y</span><br><span class="line"><span class="comment"># 配置docker开机自启</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>


<p>背景：需要一个工具，帮助我们管理集群资源，以及能够提供部署方案。采用kubernetes(k8s) + rancher的方案</p>
<p>我们选择rancher2.4+版本，原因因为2.5+删除了一键增加节点的方式，懒得折腾了</p>
<p>安装rancher server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line"> --restart=unless-stopped \</span><br><span class="line"> --privileged \</span><br><span class="line">  -p 80:80 -p 443:443 \</span><br><span class="line">  -v /opt/rancher:/var/lib/rancher \</span><br><span class="line">  rancher/rancher:v2.4.16</span><br></pre></td></tr></table></figure>

<p>导入主机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.4.16 --server https://10.77.70.135 --token &#123;token&#125; --worker</span><br></pre></td></tr></table></figure>

<p>passwd:RUC500</p>
<h3 id="搭建私有镜像库"><a href="#搭建私有镜像库" class="headerlink" title="搭建私有镜像库"></a>搭建私有镜像库</h3><p>详细过程可以查看docker registry<a href="https://docs.docker.com/registry/deploying/" target="_blank" rel="noopener">官方文档</a></p>
<ol>
<li>使用openssl生成私有证书。openssl配置文件的参数说明可以查看<a href="https://www.cnblogs.com/f-ck-need-u/p/6091027.html" target="_blank" rel="noopener">openssl.cnf</a></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat ssl.config </span><br><span class="line">[ req ]</span><br><span class="line">prompt             = no /* 设置为no将不提示输入DN field，而是直接从配置文件中读取，需要同时设置DN默认值，否则创建证书请求时将出错。 */</span><br><span class="line">distinguished_name = req_subj /* 可识别的字段名(常被简称为DN) */</span><br><span class="line">x509_extensions    = x509_ext /* 加入到自签证书中的扩展项 */</span><br><span class="line"></span><br><span class="line">[ req_subj ]</span><br><span class="line">CN = Localhost</span><br><span class="line"></span><br><span class="line">[ x509_ext ]</span><br><span class="line">subjectKeyIdentifier   = <span class="built_in">hash</span></span><br><span class="line">authorityKeyIdentifier = keyid,issuer</span><br><span class="line">basicConstraints       = CA:<span class="literal">true</span>  /* 基本约束，CA:FALSE表示该证书不能作为CA证书，即不能给其他人颁发证书*/</span><br><span class="line">subjectAltName         = @alternate_names </span><br><span class="line"></span><br><span class="line">[ alternate_names ] 带有 SAN 扩展</span><br><span class="line">DNS.1 = localhost</span><br><span class="line">IP.1  = 10.77.70.135</span><br><span class="line"></span><br><span class="line">$ openssl req -config ssl.conf -new -x509 -nodes -sha256 -days 365 -newkey rsa:4096 -keyout /certs/domain.key -out /certs/domain.crt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动registry镜像，对外暴露的端口为4433</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name ruc_registry \</span><br><span class="line">  -v /opt/docker/certs:/certs \</span><br><span class="line">  -v /opt/docker/registry:/var/lib/registry \</span><br><span class="line">  -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=//certs/domain.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \</span><br><span class="line">  -p 4433:443 \</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>把证书文件domain.crt发送给其他要使用该私有镜像库的服务器<blockquote>
<p>路径为/etc/docker/certs.d/&lt;docker registry url&gt;,文件名为ca.crt</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/10.77.70.135:4433</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>搭建NFS系统：以10.77.70.135为master server（centos服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install rpcbind nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建同步的文件夹</span></span><br><span class="line">mkdir /data/share/</span><br><span class="line">chmod 755 -R /data/share/</span><br></pre></td></tr></table></figure>

<p>配置NFS参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/exports文件添加记录</span></span><br><span class="line">/home/centos/share 10.77.70.0/24(rw,no_root_squash,no_all_squash,sync)</span><br></pre></td></tr></table></figure>

<p>启动NFS服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl start nfs</span><br></pre></td></tr></table></figure>

<p>重启NFS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo exportfs -r</span><br></pre></td></tr></table></figure>

<p>挂载NFS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs 10.77.70.135:/home/centos/share  &lt;&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://thegloves.github.io/2021/11/02/cloud-FS/" data-id="cli7gx0wi0003vowd10uybs0j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-index-md" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/24/index-md/" class="article-date">
  <time datetime="2021-09-24T08:28:15.000Z" itemprop="datePublished">2021-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/24/index-md/">Hi, welcome to my blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>欢迎来到我的博客，笔者目前是一个即将毕业进入互联网职场的新人。在学习过程中，看了不少博客，现在也想用文字记录一下自己的一些笔记，也会有一些杂七杂八的，总之不是一个纯粹的技术博客。</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>喜欢分布式，研究生研究方向是区块链共识，工作方向是大数据工程师，偏向数据集成。闲暇时喜欢打游戏 + 吹口琴（blues + 半音阶）。</p>
<p>研究兴趣：分布式；共识；TLAPLUS</p>
<p>可以通过下方的方式联系到我：</p>
<ul>
<li>github: <a href="https://github.com/theGloves" target="_blank" rel="noopener">theGloves</a></li>
<li>email: <a href="mailto:yusfko@hotmail.com">yusfko@hotmail.com</a></li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>braft源码阅读</li>
<li>raft工程实践之成员变更</li>
<li>paxos及变种的TLA spec &amp; safety</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://thegloves.github.io/2021/09/24/index-md/" data-id="cli7gx0wp000evowdhemsecau" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-general-request-link" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/24/kafka-general-request-link/" class="article-date">
  <time datetime="2021-09-24T08:28:04.000Z" itemprop="datePublished">2021-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/24/kafka-general-request-link/">kafka通用请求链路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>（这是笔者在美团实习时做的一次源码分享，当时直接将本文当作slide，所以很多地方写得比较简略）<br>本文以Kafka 0.10.0为例，追踪broker端通用请求处理链路。本文侧重一个请求在Kafka的组件中如何流转，不会涉及太多网络层（Java NIO）和请求具体的处理实现。</p>
<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>TODO 流程图，时序</p>
<p>一个请求完整的请求链路：</p>
<ol>
<li>客户端请求建立连接</li>
<li>acceptor监听到连接事件，客户端的新连接到来</li>
<li>acceptor将新连接分配给某个processor，连接建立成功，processor等待收到客户端的请求就绪</li>
<li>客户端发送请求，processor监听到请求就绪事件</li>
<li>解析请求，转换成内部的request数据，加入到requestQueue中</li>
<li>handler从request queue中poll到请求</li>
<li>将请求转移给KafkaAPIs组件处理</li>
<li>handler或者延时组件生成对应的response，写到请求所在processor的response queue中</li>
<li>processor每次poll从自己的response queue取出response</li>
<li>processor将response写入对应的Socket Channel</li>
<li>网络线程将response返回给客户端</li>
</ol>
<h2 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h2><p>通过KafkaServer的启动流程，了解到和通用请求处理相关的组件有三个：</p>
<ol>
<li>SocketServer：负责连接的建立、接受request和发送response<ul>
<li>RequestChannel：这个组件比较特殊，它是连接Socket和Apis的逻辑channel，由SocketServer负责管理</li>
</ul>
</li>
<li>KafkaApis：统一的请求处理入口，将请求转交给对应的组件处理。同时Apis也要负责控制请求的频率</li>
<li>KafkaRequestHandlerPool：存放requestHandler的pool</li>
</ol>
<p>TODO 逻辑视图</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>, time: <span class="type">Time</span> = <span class="type">SystemTime</span>, threadNamePrefix: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Start up API for bringing up a single instance of the Kafka server.</span></span><br><span class="line"><span class="comment">   * Instantiates the LogManager, the SocketServer and the request handlers - KafkaRequestHandlers</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startup</span></span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      info(<span class="string">"starting"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(isShuttingDown.get)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Kafka server is still shutting down, cannot re-start!"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(startupComplete.get)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> canStartup = isStartingUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (canStartup) &#123;</span><br><span class="line">        metrics = <span class="keyword">new</span> <span class="type">Metrics</span>(metricConfig, reporters, kafkaMetricsTime, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        brokerState.newState(<span class="type">Starting</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start scheduler */</span></span><br><span class="line">        kafkaScheduler.startup()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* setup zookeeper */</span></span><br><span class="line">        zkUtils = initZk()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start log manager */</span></span><br><span class="line">        logManager = createLogManager(zkUtils.zkClient, brokerState)</span><br><span class="line">        logManager.startup()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* generate brokerId */</span></span><br><span class="line">        config.brokerId =  getBrokerId</span><br><span class="line">        <span class="keyword">this</span>.logIdent = <span class="string">"[Kafka Server "</span> + config.brokerId + <span class="string">"], "</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 初始化好acceptor线程和processor线程，注册好监听事件</span></span><br><span class="line">        socketServer = <span class="keyword">new</span> <span class="type">SocketServer</span>(config, metrics, kafkaMetricsTime)</span><br><span class="line">        socketServer.startup()</span><br><span class="line">        <span class="comment">// 到这里，broker其实已经能够接受连接和请求了，只是请求还没法处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... replica、controller、group coordinator、authorizer等组件的初始化和启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* start processing requests */</span></span><br><span class="line">        apis = <span class="keyword">new</span> <span class="type">KafkaApis</span>(socketServer.requestChannel, replicaManager, groupCoordinator,</span><br><span class="line">          kafkaController, zkUtils, config.brokerId, config, metadataCache, metrics, authorizer)</span><br><span class="line">        <span class="comment">// 初始化好requestHandler线程，完成后broker可以开始正常工作</span></span><br><span class="line">        requestHandlerPool = <span class="keyword">new</span> <span class="type">KafkaRequestHandlerPool</span>(config.brokerId, socketServer.requestChannel, apis, config.numIoThreads)</span><br><span class="line">        brokerState.newState(<span class="type">RunningAsBroker</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">        fatal(<span class="string">"Fatal error during KafkaServer startup. Prepare to shutdown"</span>, e)</span><br><span class="line">        isStartingUp.set(<span class="literal">false</span>)</span><br><span class="line">        shutdown()</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kafka启动时，会先初始化好socket server，然后再去初始化接口KafkaApis和handler线程。下面我们依次深入三个关键组件的初始化和启动</p>
<h3 id="SocketServer"><a href="#SocketServer" class="headerlink" title="SocketServer"></a>SocketServer</h3><p>SocketServer负责网络相关的事件：连接的管理、request和response的收发。SocketServer的核心是network NIO，简单来说，就是用户以异步的方式来等待网络数据准备好，不会因为等待某个请求，使得整个线程阻塞住。从使用上来看，线程每隔一段时间就去网络层那里查看有没有传输完的请求，如果有就处理，没有就随用户操作。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>SocketServer的初始化主要是根据配置，为acceptor线程和processor线程的array预留好空间，同时初始化好RequestChannel</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>, val metrics: <span class="type">Metrics</span>, val time: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> endpoints = config.listeners <span class="comment">// "listeners" broker监听的端口列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> numProcessorThreads = config.numNetworkThreads <span class="comment">// "num.network.threads" 配置里设置的网络线程数N</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> maxQueuedRequests = config.queuedMaxRequests <span class="comment">// "queued.max.requests" 请求队列的长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> totalProcessorThreads = numProcessorThreads * endpoints.size <span class="comment">// 总共的网络线程数，一个endpoint会有N个网络线程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIp = config.maxConnectionsPerIp <span class="comment">// "max.connections.per.ip" 每个ip最大的连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIpOverrides = config.maxConnectionsPerIpOverrides <span class="comment">// "max.connections.per.ip.overrides" ？</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logIdent = <span class="string">"[Socket Server on Broker "</span> + config.brokerId + <span class="string">"], "</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> requestChannel = <span class="keyword">new</span> <span class="type">RequestChannel</span>(totalProcessorThreads, maxQueuedRequests) <span class="comment">// 连接SocketServer和KafkaAPi的逻辑channel，存放两种关键队列：requestQueue、responseQueue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> processors = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Processor</span>](totalProcessorThreads) <span class="comment">// 所有的网络线程组成一个Array，每N个网络线程属于同一个endpoint</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[network] <span class="keyword">val</span> acceptors = mutable.<span class="type">Map</span>[<span class="type">EndPoint</span>, <span class="type">Acceptor</span>]() <span class="comment">// acceptor线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> connectionQuotas: <span class="type">ConnectionQuotas</span> = _ <span class="comment">// 》</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> allMetricNames = (<span class="number">0</span> until totalProcessorThreads).map &#123; i =&gt;</span><br><span class="line">    <span class="keyword">val</span> tags = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]()</span><br><span class="line">    tags.put(<span class="string">"networkProcessor"</span>, i.toString)</span><br><span class="line">    metrics.metricName(<span class="string">"io-wait-ratio"</span>, <span class="string">"socket-server-metrics"</span>, tags)</span><br><span class="line">  &#125; <span class="comment">// 每个processor的io-ratio统计指标</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// register the processor threads for notification of responses</span></span><br><span class="line">  requestChannel.addResponseListener(id =&gt; processors(id).wakeup())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SocketServer</span>负责<span class="type">RequstChannel</span>的初始化 - 主要是两种队列的初始化：requestQueue和responseQueue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestChannel</span>(<span class="params">val numProcessors: <span class="type">Int</span>, val queueSize: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 主要是两种队列的初始化，需要注意的是</span></span><br><span class="line">  <span class="comment">// 所有线程共用一个requestQueue</span></span><br><span class="line">  <span class="comment">// 每个processor线程各自拥有ResponseQueue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> responseListeners: <span class="type">List</span>[(<span class="type">Int</span>) =&gt; <span class="type">Unit</span>] = <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> requestQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Request</span>](queueSize)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> responseQueues = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">BlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]](numProcessors)</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until numProcessors)</span><br><span class="line">    responseQueues(i) = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>用户可以给Kafka配置多个监听地址endpoint，SocketServer启动时会为每个endpoint启动一个acceptor线程，然后每一个acceptor线程配N个processor线程。当acceptor线程启动成功后，SocketServer的启动也随之完成。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>, val metrics: <span class="type">Metrics</span>, val time: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startup</span></span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.synchronized &#123;</span><br><span class="line">      connectionQuotas = <span class="keyword">new</span> <span class="type">ConnectionQuotas</span>(maxConnectionsPerIp, maxConnectionsPerIpOverrides) <span class="comment">// 连接数计数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> sendBufferSize = config.socketSendBufferBytes <span class="comment">// "socket.send.buffer.bytes" 发送缓存区大小</span></span><br><span class="line">      <span class="keyword">val</span> recvBufferSize = config.socketReceiveBufferBytes <span class="comment">// "socket.receive.buffer.bytes" 接受缓存区大小</span></span><br><span class="line">      <span class="keyword">val</span> brokerId = config.brokerId <span class="comment">// "broker.id"</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> processorBeginIndex = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 一个endpoint对应一个acceptor，一个acceptor对应N个processor</span></span><br><span class="line">      endpoints.values.foreach &#123; endpoint =&gt;</span><br><span class="line">        <span class="keyword">val</span> protocol = endpoint.protocolType</span><br><span class="line">        <span class="keyword">val</span> processorEndIndex = processorBeginIndex + numProcessorThreads</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- processorBeginIndex until processorEndIndex) &#123;</span><br><span class="line">          <span class="comment">// 初始化Processor线程，主要是初始化Selector</span></span><br><span class="line">          processors(i) = newProcessor(i, connectionQuotas, protocol)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里启动的processor线程</span></span><br><span class="line">        <span class="comment">// 初始化acceptor线程，同时启动绑定的processor线程</span></span><br><span class="line">        <span class="keyword">val</span> acceptor = <span class="keyword">new</span> <span class="type">Acceptor</span>(endpoint, sendBufferSize, recvBufferSize, brokerId,</span><br><span class="line">          processors.slice(processorBeginIndex, processorEndIndex), connectionQuotas)</span><br><span class="line">        acceptors.put(endpoint, acceptor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里为什么不用daemon方式启动线程？</span></span><br><span class="line">        <span class="type">Utils</span>.newThread(<span class="string">"kafka-socket-acceptor-%s-%d"</span>.format(protocol.toString, endpoint.port), acceptor, <span class="literal">false</span>).start()</span><br><span class="line">        acceptor.awaitStartup() <span class="comment">// 在这里等待acceptor启动成功后才恢复执行（acceptor注册OP_ACCEPT事件成功）</span></span><br><span class="line">        processorBeginIndex = processorEndIndex</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newGauge(<span class="string">"NetworkProcessorAvgIdlePercent"</span>,</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Gauge</span>[<span class="type">Double</span>] &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">value</span> </span>= allMetricNames.map( metricName =&gt;</span><br><span class="line">          metrics.metrics().get(metricName).value()).sum / totalProcessorThreads</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    info(<span class="string">"Started "</span> + acceptors.size + <span class="string">" acceptor threads"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KafkaApis"><a href="#KafkaApis" class="headerlink" title="KafkaApis"></a>KafkaApis</h3><p>不展开看了，主要是配额器quotaManager的初始化。KafkaApis的主要功能就是将request dispatch到相应的组件上</p>
<h3 id="KafkaRequestHandlerPool"><a href="#KafkaRequestHandlerPool" class="headerlink" title="KafkaRequestHandlerPool"></a>KafkaRequestHandlerPool</h3><p>在初始化KafkaRequestHandlerPool时，SocketServer已经启动好了，说明所有的acceptor和processor已经就绪，broker已经能够接受请求了，所以KafkaRequestHandlerPool的初始化主要完成KafkaRequestHandler线程的启动，启动成功后就可以开始处理请求。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaRequestHandlerPool</span>(<span class="params">val brokerId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              val requestChannel: <span class="type">RequestChannel</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              val apis: <span class="type">KafkaApis</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                              numThreads: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">KafkaMetricsGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* a meter to track the average free capacity of the request handlers */</span></span><br><span class="line">  <span class="comment">// handler的idle percent指标是聚合后的结果</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> aggregateIdleMeter = newMeter(<span class="string">"RequestHandlerAvgIdlePercent"</span>, <span class="string">"percent"</span>, <span class="type">TimeUnit</span>.<span class="type">NANOSECONDS</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.logIdent = <span class="string">"[Kafka Request Handler on Broker "</span> + brokerId + <span class="string">"], "</span></span><br><span class="line">  <span class="comment">// TODO 弄清楚threads和runnables的区别</span></span><br><span class="line">  <span class="keyword">val</span> threads = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Thread</span>](numThreads) <span class="comment">// 后台启动的handler线程</span></span><br><span class="line">  <span class="keyword">val</span> runnables = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">KafkaRequestHandler</span>](numThreads) <span class="comment">// 存放handler线程</span></span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until numThreads) &#123;</span><br><span class="line">    runnables(i) = <span class="keyword">new</span> <span class="type">KafkaRequestHandler</span>(i, brokerId, aggregateIdleMeter, numThreads, requestChannel, apis)</span><br><span class="line">    <span class="comment">// 以Daemon方式启动线程</span></span><br><span class="line">    threads(i) = <span class="type">Utils</span>.daemonThread(<span class="string">"kafka-request-handler-"</span> + i, runnables(i))</span><br><span class="line">    threads(i).start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>() &#123;</span><br><span class="line">    info(<span class="string">"shutting down"</span>)</span><br><span class="line">    <span class="keyword">for</span>(handler &lt;- runnables)</span><br><span class="line">      handler.shutdown</span><br><span class="line">    <span class="keyword">for</span>(thread &lt;- threads)</span><br><span class="line">      thread.join</span><br><span class="line">    info(<span class="string">"shut down completely"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>通过前面的总体流程，我们可以看到一个请求会在不同的线程中处理和转发，在这一部分，我们会关注每个线程具体的操作。总的来说，Kafka的网络线程模型采用的 Reactor 多线程模型：一个1+N+M模型：1个acceptor，N个processor，M个handler</p>
<ul>
<li>acceptor：监听端口，接受新连接的到来，将新连接以轮询的方式派发给processor</li>
<li>processor：接受request，发送response</li>
<li>handler：通过requestQueue，处理processor发来的request，生成response加入到response queue中</li>
</ul>
<p>网络模型除了reactor模型外，还有Proactor模型，本文不再展开，如果有兴趣可以参阅高性能网络框架：Reactor 和 Proactor TOOD link</p>
<h3 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h3><p>acceptor的主要工作是监听端口，将新来的连接以轮询的方式派发给自己拥有的processor线程。因为acceptor处于连接入口，所以acceptor同时肩负着控制连接数的重任。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 注册OP_ACCEPT事件，当有新的客户端连接到来时，事件触发</span></span><br><span class="line">  <span class="comment">// 类似的事件还有OP_CONNECT，但是OP_CONNECT只能给client端使用，语义：SocketChannel.connect()请求连接成功后就绪</span></span><br><span class="line">  serverChannel.register(nioSelector, <span class="type">SelectionKey</span>.<span class="type">OP_ACCEPT</span>)</span><br><span class="line">  startupComplete() <span class="comment">// 计数减1，当计数为0时唤醒所有的await，在这里执行成功之后SocketServer.startup()被唤醒继续执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentProcessor = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> ready = nioSelector.select(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> (ready &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果有新的连接</span></span><br><span class="line">          <span class="keyword">val</span> keys = nioSelector.selectedKeys()</span><br><span class="line">          <span class="keyword">val</span> iter = keys.iterator()</span><br><span class="line">          <span class="keyword">while</span> (iter.hasNext &amp;&amp; isRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">val</span> key = iter.next</span><br><span class="line">              iter.remove()</span><br><span class="line">              <span class="keyword">if</span> (key.isAcceptable)</span><br><span class="line">                 <span class="comment">// round-robin，processor只是简单地将该连接的channel加到一个list中，等到下一次poll在更新</span></span><br><span class="line">                accept(key, processors(currentProcessor))</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Unrecognized key state for acceptor thread."</span>)</span><br><span class="line"></span><br><span class="line">              <span class="comment">// round robin to the next processor thread</span></span><br><span class="line">              currentProcessor = (currentProcessor + <span class="number">1</span>) % processors.length</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error while accepting connection"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// We catch all the throwables to prevent the acceptor thread from exiting on exceptions due</span></span><br><span class="line">        <span class="comment">// to a select operation on a specific channel or a bad request. We don't want the</span></span><br><span class="line">        <span class="comment">// the broker to stop responding to requests from other clients in these scenarios.</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error occurred"</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    debug(<span class="string">"Closing server socket and selector."</span>)</span><br><span class="line">    swallowError(serverChannel.close())</span><br><span class="line">    swallowError(nioSelector.close())</span><br><span class="line">    shutdownComplete()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新连接到来时acceptor具体的操作：为新来的连接生成好socketChannel，然后将socketChannel转移给processor。但是processor收到新连接，并不会马上处理，而是将其暂时缓存，到下一轮poll统一处理</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acceptor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(key: <span class="type">SelectionKey</span>, processor: <span class="type">Processor</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> serverSocketChannel = key.channel().asInstanceOf[<span class="type">ServerSocketChannel</span>]</span><br><span class="line">    <span class="keyword">val</span> socketChannel = serverSocketChannel.accept() <span class="comment">// accept什么？</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里如果同一个address的连接数超过限制则会抛出TooManyConnectionsException异常拒绝处理</span></span><br><span class="line">      connectionQuotas.inc(socketChannel.socket().getInetAddress)</span><br><span class="line">      socketChannel.configureBlocking(<span class="literal">false</span>)</span><br><span class="line">      socketChannel.socket().setTcpNoDelay(<span class="literal">true</span>)      <span class="comment">// 开启TCP_NODELAY，禁用Nagle算法，允许小包发送</span></span><br><span class="line">      socketChannel.socket().setKeepAlive(<span class="literal">true</span>)</span><br><span class="line">      socketChannel.socket().setSendBufferSize(sendBufferSize)</span><br><span class="line"></span><br><span class="line">      debug(<span class="string">"Accepted connection from %s on %s and assigned it to processor %d, sendBufferSize [actual|requested]: [%d|%d] recvBufferSize [actual|requested]: [%d|%d]"</span></span><br><span class="line">            .format(socketChannel.socket.getRemoteSocketAddress, socketChannel.socket.getLocalSocketAddress, processor.id,</span><br><span class="line">                  socketChannel.socket.getSendBufferSize, sendBufferSize,</span><br><span class="line">                  socketChannel.socket.getReceiveBufferSize, recvBufferSize))</span><br><span class="line"></span><br><span class="line">      processor.accept(socketChannel) <span class="comment">// 将channel转移给processor处理，processor只是简单的加到一个队列中，等待下一轮poll才会真正处理心连接</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">TooManyConnectionsException</span> =&gt;</span><br><span class="line">        info(<span class="string">"Rejected connection from %s, address already has the configured maximum of %d connections."</span>.format(e.ip, e.count))</span><br><span class="line">        close(socketChannel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(socketChannel: <span class="type">SocketChannel</span>) &#123;</span><br><span class="line">    newConnections.add(socketChannel)</span><br><span class="line">    wakeup() <span class="comment">// 如果selector因为IO block，那么唤醒它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="processor线程"><a href="#processor线程" class="headerlink" title="processor线程"></a>processor线程</h3><p>processor负责接收客户端的请求，同时将请求结果回复给客户端。processor一次循环会依次处理：</p>
<ol>
<li>注册上一轮poll期间acceptor分配来的新连接</li>
<li>处理新的response任务</li>
<li>执行selector.poll，等待IO事件</li>
<li>处理新的就绪请求，将其加入到RequstQueue</li>
<li>处理发送成功的response，将发送完的response从inflightResponse队列中删除</li>
<li>如果有连接关闭，将与其相关的response从inflightResponse队列中删除</li>
</ol>
<p>TODO 这里的顺序可以变动吗</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">   startupComplete() <span class="comment">// 已经启动，计数器减一，不过暂时没有地方等待processor的启动成功</span></span><br><span class="line">   <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// setup any new connections that have been queued up</span></span><br><span class="line">       <span class="comment">// 1.首先注册上一轮poll期间到达的新连接</span></span><br><span class="line">       configureNewConnections()</span><br><span class="line">       <span class="comment">// register any new responses for writing</span></span><br><span class="line">       processNewResponses() <span class="comment">// 2. 处理这个processor的新的response任务</span></span><br><span class="line">       poll() <span class="comment">// 3.selector.poll(300)，如果有就绪消息事件，或者超时事件发生，否则会一直block</span></span><br><span class="line">       processCompletedReceives() <span class="comment">// 4.处理完整接收好的请求，加入到requestQueue，这一步会因为竞争被阻塞</span></span><br><span class="line">       processCompletedSends() <span class="comment">// 5.更新inflightResponses队列，将发送完的response从队列中删除</span></span><br><span class="line">       processDisconnected() <span class="comment">// 6.有连接关闭，清理inflightResponses队列中相关的response</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">       <span class="comment">// We catch all the throwables here to prevent the processor thread from exiting. We do this because</span></span><br><span class="line">       <span class="comment">// letting a processor exit might cause a bigger impact on the broker. Usually the exceptions thrown would</span></span><br><span class="line">       <span class="comment">// be either associated with a specific socket channel or a bad request. We just ignore the bad socket channel</span></span><br><span class="line">       <span class="comment">// or request. This behavior might need to be reviewed if we see an exception that need the entire broker to stop.</span></span><br><span class="line">       <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">       <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">         error(<span class="string">"Processor got uncaught exception."</span>, e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   debug(<span class="string">"Closing selector - processor "</span> + id)</span><br><span class="line">   swallowError(closeAll())</span><br><span class="line">   shutdownComplete()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册新连接"><a href="#注册新连接" class="headerlink" title="注册新连接"></a>注册新连接</h3><p>主要要向selector注册新连接的ON_READ事件，后续收到数据才能被唤醒</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">configureNewConnections</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!newConnections.isEmpty) &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = newConnections.poll()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      debug(<span class="string">s"Processor <span class="subst">$id</span> listening to new connection from <span class="subst">$&#123;channel.socket.getRemoteSocketAddress&#125;</span>"</span>)</span><br><span class="line">      <span class="keyword">val</span> localHost = channel.socket().getLocalAddress.getHostAddress</span><br><span class="line">      <span class="keyword">val</span> localPort = channel.socket().getLocalPort</span><br><span class="line">      <span class="keyword">val</span> remoteHost = channel.socket().getInetAddress.getHostAddress</span><br><span class="line">      <span class="keyword">val</span> remotePort = channel.socket().getPort</span><br><span class="line">      <span class="comment">// 生成唯一的connectionId</span></span><br><span class="line">      <span class="keyword">val</span> connectionId = <span class="type">ConnectionId</span>(localHost, localPort, remoteHost, remotePort).toString</span><br><span class="line">      <span class="comment">// 向selector注册channel的OP_READ事件</span></span><br><span class="line">      selector.register(connectionId, channel)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// We explicitly catch all non fatal exceptions and close the socket to avoid a socket leak. The other</span></span><br><span class="line">      <span class="comment">// throwables will be caught in processor and logged as uncaught exceptions.</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        <span class="comment">// need to close the channel here to avoid a socket leak.</span></span><br><span class="line">        close(channel)</span><br><span class="line">        error(<span class="string">s"Processor <span class="subst">$id</span> closed connection from <span class="subst">$&#123;channel.getRemoteAddress&#125;</span>"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理新的response"><a href="#处理新的response" class="headerlink" title="处理新的response"></a>处理新的response</h3><p>将新的response发送给selector后，将其加入到inflightResponse中，inflightResponse表示正在发送的response</p>
<p>TODO 插入一点NIO的基本知识</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processNewResponses</span></span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> curr = requestChannel.receiveResponse(id)</span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      curr.responseAction <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">NoOpAction</span> =&gt;</span><br><span class="line">          <span class="comment">// There is no response to send to the client, we need to read more pipelined requests</span></span><br><span class="line">          <span class="comment">// that are sitting in the server's socket buffer</span></span><br><span class="line">          curr.request.updateRequestMetrics</span><br><span class="line">          trace(<span class="string">"Socket server received empty response to send, registering for read: "</span> + curr)</span><br><span class="line">          <span class="comment">// 请求不需要回复，已经处理完，unmute channel</span></span><br><span class="line">          selector.unmute(curr.request.connectionId)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">SendAction</span> =&gt;</span><br><span class="line">          <span class="comment">// 将response发送给selector</span></span><br><span class="line">          sendResponse(curr)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">CloseConnectionAction</span> =&gt;</span><br><span class="line">          curr.request.updateRequestMetrics</span><br><span class="line">          trace(<span class="string">"Closing socket connection actively according to the response code."</span>)</span><br><span class="line">          close(selector, curr.request.connectionId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      curr = requestChannel.receiveResponse(id) <span class="comment">// 循环迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* `protected` for test usage */</span></span><br><span class="line"><span class="keyword">protected</span>[network] <span class="function"><span class="keyword">def</span> <span class="title">sendResponse</span></span>(response: <span class="type">RequestChannel</span>.<span class="type">Response</span>) &#123;</span><br><span class="line">  trace(<span class="string">s"Socket server received response to send, registering for write and sending data: <span class="subst">$response</span>"</span>)</span><br><span class="line">  <span class="keyword">val</span> channel = selector.channel(response.responseSend.destination)</span><br><span class="line">  <span class="comment">// `channel` can be null if the selector closed the connection because it was idle for too long</span></span><br><span class="line">  <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 连接关闭了</span></span><br><span class="line">    warn(<span class="string">s"Attempting to send response via channel for which there is no open connection, connection id <span class="subst">$id</span>"</span>)</span><br><span class="line">    response.request.updateRequestMetrics()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将response发送给selector，然后将其加入到inflightResponses队列</span></span><br><span class="line">    selector.send(response.responseSend)</span><br><span class="line">    inflightResponses += (response.request.connectionId -&gt; response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>主要是调用selector.poll函数，这个函数以non-blocking的方式完成网络IO操作，如果没有就绪的请求，最多等待300ms返回</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">poll</span></span>() &#123;</span><br><span class="line">   <span class="keyword">try</span> selector.poll(<span class="number">300</span>) <span class="comment">//在这里沉睡</span></span><br><span class="line">   <span class="keyword">catch</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> e @ (_: <span class="type">IllegalStateException</span> | _: <span class="type">IOException</span>) =&gt;</span><br><span class="line">       error(<span class="string">s"Closing processor <span class="subst">$id</span> due to illegal state or IO exception"</span>)</span><br><span class="line">       swallow(closeAll())</span><br><span class="line">       shutdownComplete()</span><br><span class="line">       <span class="keyword">throw</span> e</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理新的就绪请求"><a href="#处理新的就绪请求" class="headerlink" title="处理新的就绪请求"></a>处理新的就绪请求</h3><p>processor将就绪请求封装成内部的Request数据，然后将其加入到RequestQueue队列， 这一步会发生锁竞争导致堵塞。</p>
<p>另外，需要注意的是，为了保证同一个连接的请求保持一来一回的顺序，请求之间保持有序，Kafka使用了mute机制</p>
<p>TODO 疑问 为什么要共用一把锁</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedReceives</span></span>() &#123;</span><br><span class="line">  selector.completedReceives.asScala.foreach &#123; receive =&gt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> channel = selector.channel(receive.source)</span><br><span class="line">      <span class="keyword">val</span> session = <span class="type">RequestChannel</span>.<span class="type">Session</span>(<span class="keyword">new</span> <span class="type">KafkaPrincipal</span>(<span class="type">KafkaPrincipal</span>.<span class="type">USER_TYPE</span>, channel.principal.getName),</span><br><span class="line">        channel.socketAddress)</span><br><span class="line">      <span class="keyword">val</span> req = <span class="type">RequestChannel</span>.<span class="type">Request</span>(processor = id, connectionId = receive.source, session = session, buffer = receive.payload, startTimeMs = time.milliseconds, securityProtocol = protocol)</span><br><span class="line">      <span class="comment">// 这里会阻塞，requestQueue是ArrayBlockingQueue</span></span><br><span class="line">      requestChannel.sendRequest(req)</span><br><span class="line">      <span class="comment">// 为了保证同一个连接上请求的有序性：后来的请求的回复不会先于早来的到达，会mute这个channel，直到请求的回复被对方接受</span></span><br><span class="line">      selector.mute(receive.source)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e @ (_: <span class="type">InvalidRequestException</span> | _: <span class="type">SchemaException</span>) =&gt;</span><br><span class="line">        <span class="comment">// note that even though we got an exception, we can assume that receive.source is valid. Issues with constructing a valid receive object were handled earlier</span></span><br><span class="line">        error(<span class="string">s"Closing socket for <span class="subst">$&#123;receive.source&#125;</span> because of error"</span>, e)</span><br><span class="line">        close(selector, receive.source)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理发送成功的response"><a href="#处理发送成功的response" class="headerlink" title="处理发送成功的response"></a>处理发送成功的response</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedSends</span></span>() &#123;</span><br><span class="line">  selector.completedSends.asScala.foreach &#123; send =&gt;</span><br><span class="line">    <span class="comment">// 将已经发送成功的response从inflightResponse中删除</span></span><br><span class="line">    <span class="keyword">val</span> resp = inflightResponses.remove(send.destination).getOrElse &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"Send for <span class="subst">$&#123;send.destination&#125;</span> completed, but not in `inflightResponses`"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.request.updateRequestMetrics()</span><br><span class="line">    <span class="comment">// 恢复channel的监听</span></span><br><span class="line">    selector.unmute(send.destination)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接关闭收尾"><a href="#连接关闭收尾" class="headerlink" title="连接关闭收尾"></a>连接关闭收尾</h3><p>处理两件事：</p>
<ul>
<li>更新inflightResponse，将相关的response删除</li>
<li>更新ConnectionQuota</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processDisconnected</span></span>() &#123;</span><br><span class="line">  selector.disconnected.asScala.foreach &#123; connectionId =&gt;</span><br><span class="line">    <span class="keyword">val</span> remoteHost = <span class="type">ConnectionId</span>.fromString(connectionId).getOrElse &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"connectionId has unexpected format: <span class="subst">$connectionId</span>"</span>)</span><br><span class="line">    &#125;.remoteHost</span><br><span class="line">    <span class="comment">// 删除所有和connectionId相关的response，同时更新metrics</span></span><br><span class="line">    inflightResponses.remove(connectionId).foreach(_.request.updateRequestMetrics())</span><br><span class="line">    <span class="comment">// the channel has been closed by the selector but the quotas still need to be updated</span></span><br><span class="line">    <span class="comment">// 更新Quota，</span></span><br><span class="line">    connectionQuotas.dec(<span class="type">InetAddress</span>.getByName(remoteHost))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KafkaRequestHandler线程"><a href="#KafkaRequestHandler线程" class="headerlink" title="KafkaRequestHandler线程"></a>KafkaRequestHandler线程</h2><p>handler从requestQueue中拉取请求，然后通过KafkaApis将请求dispatch到相应的组件上继续处理，handler主要负责两件事：</p>
<ul>
<li>请求的执行，一般会把请求从KafkaApis转移到其他组件继续执行</li>
<li>生成response，一般是把生成response的操作封装成一个函数，将其传入到其他组件。当其他组件处理完请求时，调用回调函数生成response消息，并将其追加到相应processor的response queue中。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> req : <span class="type">RequestChannel</span>.<span class="type">Request</span> = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">while</span> (req == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We use a single meter for aggregate idle percentage for the thread pool.</span></span><br><span class="line">        <span class="comment">// Since meter is calculated as total_recorded_value / time_window and</span></span><br><span class="line">        <span class="comment">// time_window is independent of the number of threads, each recorded idle</span></span><br><span class="line">        <span class="comment">// time should be discounted by # threads.</span></span><br><span class="line">        <span class="keyword">val</span> startSelectTime = <span class="type">SystemTime</span>.nanoseconds</span><br><span class="line">        <span class="comment">// receiveRequest有两个实现，还有一个无参实现，两者的区别在于调用ArrayBlockingQueue不同的接口</span></span><br><span class="line">        <span class="comment">// 带timeout的调用queue.poll(timeout) ，如果没有数据等待timeout后返回空</span></span><br><span class="line">        <span class="comment">// 无参的调用queue.take() 如果没有数据，则会挂起等待，直到有数据</span></span><br><span class="line">        req = requestChannel.receiveRequest(<span class="number">300</span>)</span><br><span class="line">        <span class="keyword">val</span> idleTime = <span class="type">SystemTime</span>.nanoseconds - startSelectTime</span><br><span class="line">        aggregateIdleMeter.mark(idleTime / totalHandlerThreads)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(req eq <span class="type">RequestChannel</span>.<span class="type">AllDone</span>) &#123;</span><br><span class="line">        <span class="comment">// 当上层关闭KafkaRequestHandlerPool，会依次调用每个handler的shutdown</span></span><br><span class="line">        <span class="comment">// 每个handler往RequestQueue里发送AllDone请求，通知run loop退出</span></span><br><span class="line">        debug(<span class="string">"Kafka request handler %d on broker %d received shut down command"</span>.format(</span><br><span class="line">          id, brokerId))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      req.requestDequeueTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line">      trace(<span class="string">"Kafka request handler %d on broker %d handling request %s"</span>.format(id, brokerId, req))</span><br><span class="line">      apis.handle(req) <span class="comment">// dispatch，请求处理转移到KafkaApis，之后在转到请求对应的组件去</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Exception when handling request"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KafkaApis.handle根据不同的请求，调用不同的函数处理</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    trace(<span class="string">"Handling request:%s from connection %s;securityProtocol:%s,principal:%s"</span>.</span><br><span class="line">      format(request.requestDesc(<span class="literal">true</span>), request.connectionId, request.securityProtocol, request.session.principal))</span><br><span class="line">    <span class="type">ApiKeys</span>.forId(request.requestId) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">// 可以看到，所有的请求都是流经同一个request queue，没有优先级的区别</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">PRODUCE</span> =&gt; handleProducerRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">FETCH</span> =&gt; handleFetchRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LIST_OFFSETS</span> =&gt; handleOffsetRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">METADATA</span> =&gt; handleTopicMetadataRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LEADER_AND_ISR</span> =&gt; handleLeaderAndIsrRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">STOP_REPLICA</span> =&gt; handleStopReplicaRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">UPDATE_METADATA_KEY</span> =&gt; handleUpdateMetadataRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">CONTROLLED_SHUTDOWN_KEY</span> =&gt; handleControlledShutdownRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">OFFSET_COMMIT</span> =&gt; handleOffsetCommitRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">OFFSET_FETCH</span> =&gt; handleOffsetFetchRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">GROUP_COORDINATOR</span> =&gt; handleGroupCoordinatorRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">JOIN_GROUP</span> =&gt; handleJoinGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">HEARTBEAT</span> =&gt; handleHeartbeatRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LEAVE_GROUP</span> =&gt; handleLeaveGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">SYNC_GROUP</span> =&gt; handleSyncGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">DESCRIBE_GROUPS</span> =&gt; handleDescribeGroupRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">LIST_GROUPS</span> =&gt; handleListGroupsRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">SASL_HANDSHAKE</span> =&gt; handleSaslHandshakeRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">API_VERSIONS</span> =&gt; handleApiVersionsRequest(request)</span><br><span class="line">      <span class="keyword">case</span> requestId =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KafkaException</span>(<span class="string">"Unknown api code "</span> + requestId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">      <span class="keyword">if</span> (request.requestObj != <span class="literal">null</span>) &#123;</span><br><span class="line">        request.requestObj.handleError(e, requestChannel, request)</span><br><span class="line">        error(<span class="string">"Error when handling request %s"</span>.format(request.requestObj), e)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = request.body.getErrorResponse(request.header.apiVersion, e)</span><br><span class="line">        <span class="keyword">val</span> respHeader = <span class="keyword">new</span> <span class="type">ResponseHeader</span>(request.header.correlationId)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If request doesn't have a default error response, we just close the connection.</span></span><br><span class="line"><span class="comment">           For example, when produce request has acks set to 0 */</span></span><br><span class="line">        <span class="keyword">if</span> (response == <span class="literal">null</span>)</span><br><span class="line">          requestChannel.closeConnection(request.processor, request)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">Response</span>(request, <span class="keyword">new</span> <span class="type">ResponseSend</span>(request.connectionId, respHeader, response)))</span><br><span class="line"></span><br><span class="line">        error(<span class="string">"Error when handling request %s"</span>.format(request.body), e)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span></span><br><span class="line">    request.apiLocalCompleteTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面我们以「follower fetch」为例，梳理一下KafkaApi侧完成一次请求需要的流程：</p>
<p>验证fetch请求合法性</p>
<ul>
<li>定义回调函数sendResponseCallback，重新定义了fetch请求的response结构和send结构</li>
<li>转到replica组件继续执行fetch请求，同时传入sendResponseCallback等结束调用生成response</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle a fetch request</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleFetchRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> fetchRequest = request.requestObj.asInstanceOf[<span class="type">FetchRequest</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 验证请求合法性，</span></span><br><span class="line">  <span class="keyword">val</span> (authorizedRequestInfo, unauthorizedRequestInfo) = fetchRequest.requestInfo.partition &#123;</span><br><span class="line">    <span class="keyword">case</span> (topicAndPartition, _) =&gt; authorize(request.session, <span class="type">Read</span>, <span class="keyword">new</span> <span class="type">Resource</span>(<span class="type">Topic</span>, topicAndPartition.topic))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> unauthorizedPartitionData = unauthorizedRequestInfo.mapValues &#123; _ =&gt;</span><br><span class="line">    <span class="type">FetchResponsePartitionData</span>(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>.code, <span class="number">-1</span>, <span class="type">MessageSet</span>.<span class="type">Empty</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the callback for sending a fetch response</span></span><br><span class="line">  <span class="comment">// 2. 定义回调函数来生成fetch response</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sendResponseCallback</span></span>(responsePartitionData: <span class="type">Map</span>[<span class="type">TopicAndPartition</span>, <span class="type">FetchResponsePartitionData</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> convertedPartitionData =</span><br><span class="line">      <span class="comment">// Need to down-convert message when consumer only takes magic value 0.</span></span><br><span class="line">      <span class="keyword">if</span> (fetchRequest.versionId &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        responsePartitionData.map &#123; <span class="keyword">case</span> (tp, data) =&gt;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We only do down-conversion when:</span></span><br><span class="line">          <span class="comment">// 1. The message format version configured for the topic is using magic value &gt; 0, and</span></span><br><span class="line">          <span class="comment">// 2. The message set contains message whose magic &gt; 0</span></span><br><span class="line">          <span class="comment">// This is to reduce the message format conversion as much as possible. The conversion will only occur</span></span><br><span class="line">          <span class="comment">// when new message format is used for the topic and we see an old request.</span></span><br><span class="line">          <span class="comment">// Please note that if the message format is changed from a higher version back to lower version this</span></span><br><span class="line">          <span class="comment">// test might break because some messages in new message format can be delivered to consumers before 0.10.0.0</span></span><br><span class="line">          <span class="comment">// without format down conversion.</span></span><br><span class="line">          <span class="keyword">val</span> convertedData = <span class="keyword">if</span> (replicaManager.getMessageFormatVersion(tp).exists(_ &gt; <span class="type">Message</span>.<span class="type">MagicValue_V0</span>) &amp;&amp;</span><br><span class="line">            !data.messages.isMagicValueInAllWrapperMessages(<span class="type">Message</span>.<span class="type">MagicValue_V0</span>)) &#123;</span><br><span class="line">            trace(<span class="string">s"Down converting message to V0 for fetch request from <span class="subst">$&#123;fetchRequest.clientId&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">FetchResponsePartitionData</span>(data.error, data.hw, data.messages.asInstanceOf[<span class="type">FileMessageSet</span>].toMessageFormat(<span class="type">Message</span>.<span class="type">MagicValue_V0</span>))</span><br><span class="line">          &#125; <span class="keyword">else</span> data</span><br><span class="line"></span><br><span class="line">          tp -&gt; convertedData</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> responsePartitionData</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mergedPartitionData = convertedPartitionData ++ unauthorizedPartitionData</span><br><span class="line"></span><br><span class="line">    mergedPartitionData.foreach &#123; <span class="keyword">case</span> (topicAndPartition, data) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (data.error != <span class="type">Errors</span>.<span class="type">NONE</span>.code)</span><br><span class="line">        debug(<span class="string">s"Fetch request with correlation id <span class="subst">$&#123;fetchRequest.correlationId&#125;</span> from client <span class="subst">$&#123;fetchRequest.clientId&#125;</span> "</span> +</span><br><span class="line">          <span class="string">s"on partition <span class="subst">$topicAndPartition</span> failed due to <span class="subst">$&#123;Errors.forCode(data.error).exceptionName&#125;</span>"</span>)</span><br><span class="line">      <span class="comment">// record the bytes out metrics only when the response is being sent</span></span><br><span class="line">      <span class="type">BrokerTopicStats</span>.getBrokerTopicStats(topicAndPartition.topic).bytesOutRate.mark(data.messages.sizeInBytes)</span><br><span class="line">      <span class="type">BrokerTopicStats</span>.getBrokerAllTopicsStats().bytesOutRate.mark(data.messages.sizeInBytes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成response数据的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetchResponseCallback</span></span>(delayTimeMs: <span class="type">Int</span>) &#123;</span><br><span class="line">      trace(<span class="string">s"Sending fetch response to client <span class="subst">$&#123;fetchRequest.clientId&#125;</span> of "</span> +</span><br><span class="line">        <span class="string">s"<span class="subst">$&#123;convertedPartitionData.values.map(_.messages.sizeInBytes).sum&#125;</span> bytes"</span>)</span><br><span class="line">      <span class="comment">// 自己重新实现了Response</span></span><br><span class="line">      <span class="keyword">val</span> response = <span class="type">FetchResponse</span>(fetchRequest.correlationId, mergedPartitionData, fetchRequest.versionId, delayTimeMs)</span><br><span class="line">      <span class="comment">// 没有用ByteBuffer的Send操作，重写了一套send方法，大概是多路写提高效率？</span></span><br><span class="line">      requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="keyword">new</span> <span class="type">FetchResponseSend</span>(request.connectionId, response)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When this callback is triggered, the remote API call has completed</span></span><br><span class="line">    request.apiRemoteCompleteTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not throttle replication traffic</span></span><br><span class="line">    <span class="keyword">if</span> (fetchRequest.isFromFollower) &#123;</span><br><span class="line">      fetchResponseCallback(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      quotaManagers(<span class="type">ApiKeys</span>.<span class="type">FETCH</span>.id).recordAndMaybeThrottle(fetchRequest.clientId,</span><br><span class="line">                                                             <span class="type">FetchResponse</span>.responseSize(mergedPartitionData.groupBy(_._1.topic),</span><br><span class="line">                                                                                        fetchRequest.versionId),</span><br><span class="line">                                                             fetchResponseCallback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (authorizedRequestInfo.isEmpty)</span><br><span class="line">    sendResponseCallback(<span class="type">Map</span>.empty)</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3. call the replica manager to fetch messages from the local replica</span></span><br><span class="line">    replicaManager.fetchMessages(</span><br><span class="line">      fetchRequest.maxWait.toLong,</span><br><span class="line">      fetchRequest.replicaId,</span><br><span class="line">      fetchRequest.minBytes,</span><br><span class="line">      authorizedRequestInfo,</span><br><span class="line">      sendResponseCallback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h2><p>整个请求链路中，存在两个对外的数据接口：Request和Response，分别对应着请求链路的入口和出口。</p>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>生成request时候需要传入processor和connectId信息，因为response是根据request生成的，生成好后需要根据request的processor信息将response放到相同processor的responseQueue中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// request和processor绑定，因为相应的response也要回到相同的processor上</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">processor: <span class="type">Int</span>, connectionId: <span class="type">String</span>, session: <span class="type">Session</span>, private var buffer: <span class="type">ByteBuffer</span>, startTimeMs: <span class="type">Long</span>, securityProtocol: <span class="type">SecurityProtocol</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// These need to be volatile because the readers are in the network thread and the writers are in the request</span></span><br><span class="line">    <span class="comment">// handler threads or the purgatory threads</span></span><br><span class="line">    <span class="comment">// 记录一个请求不同阶段的耗，在调用updateRequestMetrics函数前，记录的是毫秒级别的时间戳</span></span><br><span class="line">    <span class="comment">// updateRequestMetrics会在processor执行processNewResponses函数时统一调用，在计算出正确的结果</span></span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> requestDequeueTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> apiLocalCompleteTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> responseCompleteTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> responseDequeueTimeMs = <span class="number">-1</span>L</span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> apiRemoteCompleteTimeMs = <span class="number">-1</span>L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> requestId = buffer.getShort()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this will be removed once we migrated to client-side format</span></span><br><span class="line">    <span class="comment">// for server-side request / response format</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> this map only includes the server-side request/response handlers. Newer</span></span><br><span class="line">    <span class="comment">// request types should only use the client-side versions which are parsed with</span></span><br><span class="line">    <span class="comment">// o.a.k.common.requests.AbstractRequest.getRequest()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> keyToNameAndDeserializerMap: <span class="type">Map</span>[<span class="type">Short</span>, (<span class="type">ByteBuffer</span>) =&gt; <span class="type">RequestOrResponse</span>]=</span><br><span class="line">      <span class="type">Map</span>(<span class="type">ApiKeys</span>.<span class="type">FETCH</span>.id -&gt; <span class="type">FetchRequest</span>.readFrom,</span><br><span class="line">        <span class="type">ApiKeys</span>.<span class="type">CONTROLLED_SHUTDOWN_KEY</span>.id -&gt; <span class="type">ControlledShutdownRequest</span>.readFrom</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this will be removed once we migrated to client-side format</span></span><br><span class="line">    <span class="keyword">val</span> requestObj =</span><br><span class="line">      keyToNameAndDeserializerMap.get(requestId).map(readFrom =&gt; readFrom(buffer)).orNull</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we failed to find a server-side mapping, then try using the</span></span><br><span class="line">    <span class="comment">// client-side request / response format</span></span><br><span class="line">    <span class="keyword">val</span> header: <span class="type">RequestHeader</span> =</span><br><span class="line">      <span class="keyword">if</span> (requestObj == <span class="literal">null</span>) &#123;</span><br><span class="line">        buffer.rewind</span><br><span class="line">        <span class="keyword">try</span> <span class="type">RequestHeader</span>.parse(buffer)</span><br><span class="line">        <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> ex: <span class="type">Throwable</span> =&gt;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidRequestException</span>(<span class="string">s"Error parsing request header. Our best guess of the apiKey is: <span class="subst">$requestId</span>"</span>, ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> body: <span class="type">AbstractRequest</span> =</span><br><span class="line">      <span class="keyword">if</span> (requestObj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// For unsupported version of ApiVersionsRequest, create a dummy request to enable an error response to be returned later</span></span><br><span class="line">          <span class="keyword">if</span> (header.apiKey == <span class="type">ApiKeys</span>.<span class="type">API_VERSIONS</span>.id &amp;&amp; !<span class="type">Protocol</span>.apiVersionSupported(header.apiKey, header.apiVersion))</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ApiVersionsRequest</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="type">AbstractRequest</span>.getRequest(header.apiKey, header.apiVersion, buffer)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> ex: <span class="type">Throwable</span> =&gt;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidRequestException</span>(<span class="string">s"Error getting request for apiKey: <span class="subst">$&#123;header.apiKey&#125;</span> and apiVersion: <span class="subst">$&#123;header.apiVersion&#125;</span>"</span>, ex)</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    buffer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> requestLogger = <span class="type">Logger</span>.getLogger(<span class="string">"kafka.request.logger"</span>)</span><br><span class="line"></span><br><span class="line">    trace(<span class="string">"Processor %d received request : %s"</span>.format(processor, requestDesc(<span class="literal">true</span>)))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>(<span class="params">processor: <span class="type">Int</span>, request: <span class="type">Request</span>, responseSend: <span class="type">Send</span>, responseAction: <span class="type">ResponseAction</span></span>) </span>&#123;</span><br><span class="line">  request.responseCompleteTimeMs = <span class="type">SystemTime</span>.milliseconds</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(processor: <span class="type">Int</span>, request: <span class="type">Request</span>, responseSend: <span class="type">Send</span>) =</span><br><span class="line">    <span class="keyword">this</span>(processor, request, responseSend, <span class="keyword">if</span> (responseSend == <span class="literal">null</span>) <span class="type">NoOpAction</span> <span class="keyword">else</span> <span class="type">SendAction</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(request: <span class="type">Request</span>, send: <span class="type">Send</span>) =</span><br><span class="line">    <span class="keyword">this</span>(request.processor, request, send)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ResponseAction</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">SendAction</span> <span class="keyword">extends</span> <span class="title">ResponseAction</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">NoOpAction</span> <span class="keyword">extends</span> <span class="title">ResponseAction</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">CloseConnectionAction</span> <span class="keyword">extends</span> <span class="title">ResponseAction</span></span></span><br></pre></td></tr></table></figure>

<p>与常见的Response有些不同，Kafka的Response不关注返回数据本身，而是关注数据如何写入socket channel，所以response主要保存的是一个函数接口send，这个接口描述了response数据以何种方式写入到channel中。processor收到这个response时，也只是将其传入NIO的队列，等待NIO网络线程想要执行发送操作时，才会调用writeTo函数，按照上层定义的方式写入数据。Send接口的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This interface models the in-progress sending of data to a destination identified by an integer id.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public interface <span class="type">Send</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The numeric id for the destination of this send</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="type">String</span> destination();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is this send complete?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public boolean completed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write some as-yet unwritten bytes from this send to the provided channel. It may take multiple calls for the send</span></span><br><span class="line"><span class="comment">     * to be completely written</span></span><br><span class="line"><span class="comment">     * @param channel The Channel to write to</span></span><br><span class="line"><span class="comment">     * @return The number of bytes written</span></span><br><span class="line"><span class="comment">     * @throws IOException If the write fails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public long writeTo(<span class="type">GatheringByteChannel</span> channel) <span class="keyword">throws</span> <span class="type">IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Size of the send</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public long size();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后续版本变动"><a href="#后续版本变动" class="headerlink" title="后续版本变动"></a>后续版本变动</h2><p><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-291%3A+Separating+controller+connections+and+requests+from+the+data+plane" target="_blank" rel="noopener">KIP-291</a><br><a href="https://issues.apache.org/jira/browse/KAFKA-4453" target="_blank" rel="noopener">Kafka-4453</a></p>
<p>0.10.0版本下，所有的控制流请求和数据流请求都在同一个request queue，如果拥堵，会导致控制流请求没法得到及时更新。所以后续的社区更新将两个流拆分成两个独立的链路，从endpoint、acceptor、processor、handler、requestQueue、APIs等，都互不干扰。当然，两者占有的资源并不是等同的，毕竟控制流请求相对会更少，一般会配备1个acceptor线程、1个processor线程和20个位置requestQueue</p>
<h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>文本通过源码阅读的方式，简略梳理了broker侧的请求处理链路，但仍有一些问题遗留：</p>
<ul>
<li>为什么acceptor、processor以普通用户线程运行，而handler则是以daemon线程运行</li>
<li>网络层selector仍是一个黑盒子，Kafka在Java network NIO的基础上进行了一些封装。</li>
<li>如果界定一个请求的边界，怎么定义一个请求的收到</li>
<li>为什么会有组件自己实现Send接口，而不是简单地使用ByteNetworkSend</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></li>
<li><a href="https://bbs.huaweicloud.com/blogs/266248?utm_source=zhihu&utm_medium=bbs-ex&utm_campaign=other&utm_content=content" target="_blank" rel="noopener">高性能网络框架：Reactor 和 Proactor</a></li>
<li><a href="http://matt33.com/2018/06/27/kafka-server-process-model" target="_blank" rel="noopener">Kafka 源码解析之 Server 1+N+M 网络处理模型</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://thegloves.github.io/2021/09/24/kafka-general-request-link/" data-id="cli7gx0wn000avowdajrp6ole" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/others/">others</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 10px;">源码阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/28/basic-raft-protocol/">basic raft protocol</a>
          </li>
        
          <li>
            <a href="/2022/07/20/tla/">tla+</a>
          </li>
        
          <li>
            <a href="/2021/11/02/cloud-FS/">基于k8s+rancher+NFS搭建云平台</a>
          </li>
        
          <li>
            <a href="/2021/09/24/index-md/">Hi, welcome to my blog</a>
          </li>
        
          <li>
            <a href="/2021/09/24/kafka-general-request-link/">kafka通用请求链路</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 theGloves<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>